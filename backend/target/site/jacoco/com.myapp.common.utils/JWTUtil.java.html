<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JWTUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Food Ordering Backend</a> &gt; <a href="index.source.html" class="el_package">com.myapp.common.utils</a> &gt; <span class="el_source">JWTUtil.java</span></div><h1>JWTUtil.java</h1><pre class="source lang-java linenums">package com.myapp.common.utils;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import javax.crypto.SecretKey;
import java.util.Date;
import java.util.concurrent.TimeUnit;

/**
 * کلاس ابزاری JWT - مدیریت تولید، اعتبارسنجی و پردازش token ها
 * این کلاس عملکرد احراز هویت امن JWT را فراهم می‌کند
 * شامل دو نوع token: Access Token و Refresh Token
 */
<span class="nc" id="L14">public class JWTUtil {</span>
    
    // کلید مخفی برای امضای JWT (در محیط production باید از متغیر محیطی دریافت شود)
    private static final String SECRET_KEY = &quot;mySecretKeyForJWTThatShouldBeVeryLongAndSecureInProductionEnvironment123456789&quot;;
    
    // زمان اعتبار token ها
<span class="fc" id="L20">    private static final long ACCESS_TOKEN_VALIDITY = TimeUnit.HOURS.toMillis(24); // 24 ساعت</span>
<span class="fc" id="L21">    private static final long REFRESH_TOKEN_VALIDITY = TimeUnit.DAYS.toMillis(7);  // 7 روز</span>
    
    // صادرکننده JWT
    private static final String ISSUER = &quot;food-ordering-app&quot;;
    
    /**
     * دریافت کلید امضای رمزنگاری شده
     * این متد کلید مخفی را به فرمت SecretKey تبدیل می‌کند
     * 
     * @return کلید امضای رمزنگاری شده
     */
    private static SecretKey getSigningKey() {
<span class="fc" id="L33">        return Keys.hmacShaKeyFor(SECRET_KEY.getBytes());</span>
    }
    
    /**
     * تولید Access Token برای کاربر احراز هویت شده
     * این token برای دسترسی به API ها استفاده می‌شود
     * 
     * @param userId شناسه کاربر
     * @param phone شماره تلفن کاربر
     * @param role نقش کاربر (customer, seller, delivery)
     * @return JWT Access Token
     * @throws IllegalArgumentException در صورت null بودن پارامترها
     */
    public static String generateAccessToken(Long userId, String phone, String role) {
        // اعتبارسنجی ورودی‌ها
<span class="fc bfc" id="L48" title="All 6 branches covered.">        if (userId == null || phone == null || role == null) {</span>
<span class="fc" id="L49">            throw new IllegalArgumentException(&quot;UserId, phone, and role cannot be null&quot;);</span>
        }
        
<span class="fc" id="L52">        Date now = new Date();                                        // زمان فعلی</span>
<span class="fc" id="L53">        Date expirationDate = new Date(now.getTime() + ACCESS_TOKEN_VALIDITY); // زمان انقضا</span>
        
<span class="fc" id="L55">        return Jwts.builder()</span>
<span class="fc" id="L56">                .subject(userId.toString())           // شناسه کاربر به عنوان subject</span>
<span class="fc" id="L57">                .claim(&quot;phone&quot;, phone)                // شماره تلفن در claim</span>
<span class="fc" id="L58">                .claim(&quot;role&quot;, role)                  // نقش کاربر در claim</span>
<span class="fc" id="L59">                .claim(&quot;type&quot;, &quot;access&quot;)              // نوع token</span>
<span class="fc" id="L60">                .issuer(ISSUER)                       // صادرکننده</span>
<span class="fc" id="L61">                .issuedAt(now)                        // زمان صدور</span>
<span class="fc" id="L62">                .expiration(expirationDate)           // زمان انقضا</span>
<span class="fc" id="L63">                .signWith(getSigningKey(), SignatureAlgorithm.HS256) // امضا با HMAC-SHA256</span>
<span class="fc" id="L64">                .compact();                           // تولید نهایی token</span>
    }
    
    /**
     * تولید Refresh Token برای کاربر
     * این token برای تجدید Access Token استفاده می‌شود
     * 
     * @param userId شناسه کاربر
     * @return JWT Refresh Token
     * @throws IllegalArgumentException در صورت null بودن userId
     */
    public static String generateRefreshToken(Long userId) {
        // اعتبارسنجی ورودی
<span class="fc bfc" id="L77" title="All 2 branches covered.">        if (userId == null) {</span>
<span class="fc" id="L78">            throw new IllegalArgumentException(&quot;UserId cannot be null&quot;);</span>
        }
        
<span class="fc" id="L81">        Date now = new Date();                                         // زمان فعلی</span>
<span class="fc" id="L82">        Date expirationDate = new Date(now.getTime() + REFRESH_TOKEN_VALIDITY); // زمان انقضا</span>
        
<span class="fc" id="L84">        return Jwts.builder()</span>
<span class="fc" id="L85">                .subject(userId.toString())           // شناسه کاربر</span>
<span class="fc" id="L86">                .claim(&quot;type&quot;, &quot;refresh&quot;)             // نوع token</span>
<span class="fc" id="L87">                .issuer(ISSUER)                       // صادرکننده</span>
<span class="fc" id="L88">                .issuedAt(now)                        // زمان صدور</span>
<span class="fc" id="L89">                .expiration(expirationDate)           // زمان انقضا</span>
<span class="fc" id="L90">                .signWith(getSigningKey(), SignatureAlgorithm.HS256) // امضا</span>
<span class="fc" id="L91">                .compact();                           // تولید نهایی token</span>
    }
    
    /**
     * اعتبارسنجی JWT token
     * بررسی امضا، صادرکننده و ساختار token
     * 
     * @param token JWT token برای اعتبارسنجی
     * @return true اگر token معتبر باشد، در غیر اینصورت false
     */
    public static boolean validateToken(String token) {
        try {
            // پردازش و اعتبارسنجی token
<span class="fc" id="L104">            Jwts.parser()</span>
<span class="fc" id="L105">                .verifyWith(getSigningKey())        // بررسی امضا</span>
<span class="fc" id="L106">                .requireIssuer(ISSUER)              // بررسی صادرکننده</span>
<span class="fc" id="L107">                .build()</span>
<span class="fc" id="L108">                .parseSignedClaims(token);          // پردازش claims</span>
<span class="fc" id="L109">            return true;</span>
<span class="fc" id="L110">        } catch (JwtException | IllegalArgumentException e) {</span>
<span class="fc" id="L111">            return false; // token نامعتبر</span>
        }
    }
    
    /**
     * دریافت شناسه کاربر از JWT token
     * 
     * @param token JWT token
     * @return شناسه کاربر
     * @throws JwtException در صورت نامعتبر بودن token
     */
    public static Long getUserIdFromToken(String token) {
<span class="fc" id="L123">        Claims claims = getClaimsFromToken(token);</span>
<span class="fc" id="L124">        return Long.parseLong(claims.getSubject()); // تبدیل subject به Long</span>
    }
    
    /**
     * دریافت شماره تلفن کاربر از JWT token
     * 
     * @param token JWT token
     * @return شماره تلفن کاربر
     * @throws JwtException در صورت نامعتبر بودن token یا عدم وجود phone
     */
    public static String getPhoneFromToken(String token) {
<span class="fc" id="L135">        Claims claims = getClaimsFromToken(token);</span>
<span class="fc" id="L136">        String phone = claims.get(&quot;phone&quot;, String.class);</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">        if (phone == null) {</span>
<span class="fc" id="L138">            throw new JwtException(&quot;Token does not contain phone claim&quot;);</span>
        }
<span class="fc" id="L140">        return phone;</span>
    }
    
    /**
     * دریافت نقش کاربر از JWT token
     * 
     * @param token JWT token
     * @return نقش کاربر
     * @throws JwtException در صورت نامعتبر بودن token یا عدم وجود role
     */
    public static String getRoleFromToken(String token) {
<span class="fc" id="L151">        Claims claims = getClaimsFromToken(token);</span>
<span class="fc" id="L152">        String role = claims.get(&quot;role&quot;, String.class);</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (role == null) {</span>
<span class="fc" id="L154">            throw new JwtException(&quot;Token does not contain role claim&quot;);</span>
        }
<span class="fc" id="L156">        return role;</span>
    }
    
    /**
     * دریافت نوع token (access/refresh) از JWT token
     * 
     * @param token JWT token
     * @return نوع token
     * @throws JwtException در صورت نامعتبر بودن token یا عدم وجود type
     */
    public static String getTokenType(String token) {
<span class="fc" id="L167">        Claims claims = getClaimsFromToken(token);</span>
<span class="fc" id="L168">        String type = claims.get(&quot;type&quot;, String.class);</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">        if (type == null) {</span>
<span class="nc" id="L170">            throw new JwtException(&quot;Token does not contain type claim&quot;);</span>
        }
<span class="fc" id="L172">        return type;</span>
    }
    
    /**
     * بررسی انقضای token
     * 
     * @param token JWT token
     * @return true اگر token منقضی شده باشد، در غیر اینصورت false
     */
    public static boolean isTokenExpired(String token) {
        try {
<span class="fc" id="L183">            Claims claims = getClaimsFromToken(token);</span>
<span class="fc" id="L184">            return claims.getExpiration().before(new Date()); // مقایسه با زمان فعلی</span>
<span class="nc" id="L185">        } catch (JwtException e) {</span>
<span class="nc" id="L186">            return true; // token های نامعتبر را منقضی در نظر می‌گیریم</span>
        }
    }
    
    /**
     * دریافت تاریخ انقضا از JWT token
     * 
     * @param token JWT token
     * @return تاریخ انقضا
     * @throws JwtException در صورت نامعتبر بودن token
     */
    public static Date getExpirationDateFromToken(String token) {
<span class="fc" id="L198">        Claims claims = getClaimsFromToken(token);</span>
<span class="fc" id="L199">        return claims.getExpiration();</span>
    }
    
    /**
     * دریافت تاریخ صدور از JWT token
     * 
     * @param token JWT token
     * @return تاریخ صدور
     * @throws JwtException در صورت نامعتبر بودن token
     */
    public static Date getIssuedAtFromToken(String token) {
<span class="nc" id="L210">        Claims claims = getClaimsFromToken(token);</span>
<span class="nc" id="L211">        return claims.getIssuedAt();</span>
    }
    
    /**
     * بررسی اینکه آیا token از نوع Access است
     * 
     * @param token JWT token
     * @return true اگر Access Token باشد، در غیر اینصورت false
     */
    public static boolean isAccessToken(String token) {
        try {
<span class="fc" id="L222">            return &quot;access&quot;.equals(getTokenType(token));</span>
<span class="fc" id="L223">        } catch (JwtException e) {</span>
<span class="fc" id="L224">            return false;</span>
        }
    }
    
    /**
     * بررسی اینکه آیا token از نوع Refresh است
     * 
     * @param token JWT token
     * @return true اگر Refresh Token باشد، در غیر اینصورت false
     */
    public static boolean isRefreshToken(String token) {
        try {
<span class="fc" id="L236">            return &quot;refresh&quot;.equals(getTokenType(token));</span>
<span class="fc" id="L237">        } catch (JwtException e) {</span>
<span class="fc" id="L238">            return false;</span>
        }
    }
    
    /**
     * استخراج Bearer Token از header Authorization
     * 
     * @param authorizationHeader مقدار header Authorization
     * @return JWT token یا null در صورت نامعتبر بودن فرمت
     */
    public static String extractBearerToken(String authorizationHeader) {
<span class="fc bfc" id="L249" title="All 4 branches covered.">        if (authorizationHeader != null &amp;&amp; authorizationHeader.startsWith(&quot;Bearer &quot;)) {</span>
<span class="fc" id="L250">            String token = authorizationHeader.substring(7).trim(); // حذف &quot;Bearer &quot; از ابتدا</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">            return token.isEmpty() ? null : token;</span>
        }
<span class="fc" id="L253">        return null;</span>
    }
    
    /**
     * دریافت زمان باقیمانده تا انقضای token (بر حسب میلی‌ثانیه)
     * 
     * @param token JWT token
     * @return زمان باقیمانده بر حسب میلی‌ثانیه، یا 0 در صورت انقضا/نامعتبر بودن
     */
    public static long getRemainingTimeToExpire(String token) {
<span class="pc bpc" id="L263" title="1 of 4 branches missed.">        if (token == null || token.trim().isEmpty()) {</span>
<span class="fc" id="L264">            return 0;</span>
        }
        try {
<span class="fc" id="L267">            Date expiration = getExpirationDateFromToken(token);</span>
<span class="fc" id="L268">            long remaining = expiration.getTime() - System.currentTimeMillis();</span>
<span class="fc" id="L269">            return Math.max(0, remaining); // حداقل 0 برگردان</span>
<span class="nc" id="L270">        } catch (JwtException | IllegalArgumentException e) {</span>
<span class="nc" id="L271">            return 0;</span>
        }
    }
    
    /**
     * بررسی داشتن نقش خاص توسط کاربر
     * 
     * @param token JWT token
     * @param requiredRole نقش مورد نیاز
     * @return true اگر کاربر نقش مورد نیاز را داشته باشد، در غیر اینصورت false
     */
    public static boolean hasRole(String token, String requiredRole) {
        try {
<span class="fc" id="L284">            String userRole = getRoleFromToken(token);</span>
<span class="fc" id="L285">            return requiredRole.equals(userRole);</span>
<span class="fc" id="L286">        } catch (JwtException e) {</span>
<span class="fc" id="L287">            return false;</span>
        }
    }
    
    /**
     * دریافت تمام claims از JWT token
     * متد کمکی برای استخراج اطلاعات از token
     * 
     * @param token JWT token
     * @return شیء Claims
     * @throws JwtException در صورت نامعتبر بودن token
     */
    private static Claims getClaimsFromToken(String token) {
<span class="fc" id="L300">        return Jwts.parser()</span>
<span class="fc" id="L301">                .verifyWith(getSigningKey())        // بررسی امضا</span>
<span class="fc" id="L302">                .requireIssuer(ISSUER)              // بررسی صادرکننده</span>
<span class="fc" id="L303">                .build()</span>
<span class="fc" id="L304">                .parseSignedClaims(token)           // پردازش token</span>
<span class="fc" id="L305">                .getPayload();                      // دریافت payload (claims)</span>
    }
    
    /**
     * تولید هر دو نوع token (Access و Refresh) برای کاربر
     * این متد هر دو token مورد نیاز را به صورت همزمان تولید می‌کند
     * 
     * @param userId شناسه کاربر
     * @param phone شماره تلفن کاربر
     * @param role نقش کاربر
     * @return آرایه شامل [accessToken, refreshToken]
     */
    public static String[] generateTokenPair(Long userId, String phone, String role) {
<span class="fc" id="L318">        String accessToken = generateAccessToken(userId, phone, role);  // تولید Access Token</span>
<span class="fc" id="L319">        String refreshToken = generateRefreshToken(userId);             // تولید Refresh Token</span>
<span class="fc" id="L320">        return new String[]{accessToken, refreshToken};                 // برگرداندن هر دو</span>
    }
    
    /**
     * دریافت دوره اعتبار Access Token بر حسب میلی‌ثانیه
     * 
     * @return دوره اعتبار Access Token
     */
    public static long getAccessTokenValidity() {
<span class="fc" id="L329">        return ACCESS_TOKEN_VALIDITY;</span>
    }
    
    /**
     * دریافت دوره اعتبار Refresh Token بر حسب میلی‌ثانیه
     * 
     * @return دوره اعتبار Refresh Token
     */
    public static long getRefreshTokenValidity() {
<span class="fc" id="L338">        return REFRESH_TOKEN_VALIDITY;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>