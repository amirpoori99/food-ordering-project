<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PasswordUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Food Ordering Backend</a> &gt; <a href="index.source.html" class="el_package">com.myapp.common.utils</a> &gt; <span class="el_source">PasswordUtil.java</span></div><h1>PasswordUtil.java</h1><pre class="source lang-java linenums">package com.myapp.common.utils;

// وارد کردن کتابخانه‌های امنیتی و رمزنگاری
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;
import java.util.regex.Pattern;

/**
 * کلاس ابزاری برای عملیات رمز عبور
 * شامل hash کردن امن، تأیید و اعتبارسنجی رمز عبور
 * از الگوریتم SHA-256 با Salt تصادفی استفاده می‌کند
 */
<span class="nc" id="L15">public class PasswordUtil {</span>
    
    // الگوریتم hash مورد استفاده
    private static final String HASH_ALGORITHM = &quot;SHA-256&quot;;
    
    // طول Salt تصادفی (32 بایت)
    private static final int SALT_LENGTH = 32;
    
    // مولد عدد تصادفی امن
<span class="fc" id="L24">    private static final SecureRandom random = new SecureRandom();</span>
    
    // الگوی اعتبارسنجی رمز عبور (حداقل 8 کاراکتر، شامل حروف کوچک، بزرگ، عدد و کاراکتر خاص)
<span class="fc" id="L27">    private static final Pattern PASSWORD_PATTERN = Pattern.compile(</span>
        &quot;^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&amp;+=])(?=\\S+$).{8,}$&quot;
    );
    
    /**
     * تولید hash امن برای رمز عبور با Salt تصادفی
     * 
     * @param password رمز عبور متنی
     * @return رشته حاوی Salt و رمز عبور hash شده جدا شده با ':'
     * @throws IllegalArgumentException در صورت null یا خالی بودن رمز عبور
     */
    public static String hashPassword(String password) {
        // اعتبارسنجی ورودی
<span class="fc bfc" id="L40" title="All 4 branches covered.">        if (password == null || password.isEmpty()) {</span>
<span class="fc" id="L41">            throw new IllegalArgumentException(&quot;Password cannot be null or empty&quot;);</span>
        }
        
        try {
            // تولید Salt تصادفی
<span class="fc" id="L46">            byte[] salt = new byte[SALT_LENGTH];</span>
<span class="fc" id="L47">            random.nextBytes(salt);</span>
            
            // hash کردن رمز عبور با Salt
<span class="fc" id="L50">            String hashedPassword = hashPasswordWithSalt(password, salt);</span>
            
            // برگرداندن در فرمت salt:hashedPassword
<span class="fc" id="L53">            return Base64.getEncoder().encodeToString(salt) + &quot;:&quot; + hashedPassword;</span>
<span class="nc" id="L54">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L55">            throw new RuntimeException(&quot;Failed to hash password&quot;, e);</span>
        }
    }
    
    /**
     * تأیید رمز عبور در مقابل hash ذخیره شده
     * 
     * @param password رمز عبور متنی برای تأیید
     * @param storedHash hash ذخیره شده در فرمت &quot;salt:hashedPassword&quot;
     * @return true اگر رمز عبور مطابقت داشته باشد، در غیر اینصورت false
     */
    public static boolean verifyPassword(String password, String storedHash) {
        // بررسی null بودن ورودی‌ها
<span class="fc bfc" id="L68" title="All 4 branches covered.">        if (password == null || storedHash == null) {</span>
<span class="fc" id="L69">            return false;</span>
        }
        
        try {
            // تجزیه hash ذخیره شده برای دریافت Salt و hash
<span class="fc" id="L74">            String[] parts = storedHash.split(&quot;:&quot;);</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">            if (parts.length != 2) {</span>
<span class="fc" id="L76">                return false; // فرمت نامعتبر</span>
            }
            
            // رمزگشایی Salt
<span class="fc" id="L80">            byte[] salt = Base64.getDecoder().decode(parts[0]);</span>
<span class="fc" id="L81">            String expectedHash = parts[1];</span>
            
            // hash کردن رمز عبور ارائه شده با همان Salt
<span class="fc" id="L84">            String actualHash = hashPasswordWithSalt(password, salt);</span>
            
            // مقایسه hash ها با روش constant-time برای جلوگیری از timing attack
<span class="fc" id="L87">            return constantTimeEquals(expectedHash, actualHash);</span>
<span class="nc" id="L88">        } catch (Exception e) {</span>
            // در برنامه واقعی باید exception را log کرد
<span class="nc" id="L90">            return false;</span>
        }
    }
    
    /**
     * hash کردن رمز عبور با Salt مشخص
     * متد کمکی برای hash کردن با Salt داده شده
     */
    private static String hashPasswordWithSalt(String password, byte[] salt) throws NoSuchAlgorithmException {
<span class="fc" id="L99">        MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);</span>
        
        // افزودن Salt به digest
<span class="fc" id="L102">        md.update(salt);</span>
        
        // hash کردن رمز عبور
<span class="fc" id="L105">        byte[] hashedPassword = md.digest(password.getBytes());</span>
        
        // برگرداندن hash encode شده با base64
<span class="fc" id="L108">        return Base64.getEncoder().encodeToString(hashedPassword);</span>
    }
    
    /**
     * مقایسه رشته با زمان ثابت برای جلوگیری از timing attack
     * این روش از timing attack جلوگیری می‌کند
     */
    private static boolean constantTimeEquals(String a, String b) {
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">        if (a.length() != b.length()) {</span>
<span class="nc" id="L117">            return false;</span>
        }
        
<span class="fc" id="L120">        int result = 0;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">        for (int i = 0; i &lt; a.length(); i++) {</span>
<span class="fc" id="L122">            result |= a.charAt(i) ^ b.charAt(i); // XOR برای مقایسه</span>
        }
        
<span class="fc bfc" id="L125" title="All 2 branches covered.">        return result == 0; // اگر همه کاراکترها یکسان باشند، result برابر 0 است</span>
    }
    
    /**
     * اعتبارسنجی قدرت رمز عبور
     * 
     * @param password رمز عبور برای اعتبارسنجی
     * @return true اگر رمز عبور الزامات قدرت را برآورده کند
     */
    public static boolean isValidPassword(String password) {
<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (password == null) {</span>
<span class="fc" id="L136">            return false;</span>
        }
        
<span class="fc" id="L139">        return PASSWORD_PATTERN.matcher(password).matches(); // بررسی با regex pattern</span>
    }
    
    /**
     * دریافت الزامات قدرت رمز عبور به صورت رشته قابل خواندن
     * 
     * @return متن شامل الزامات رمز عبور
     */
    public static String getPasswordRequirements() {
<span class="fc" id="L148">        return &quot;Password must contain:\n&quot; +</span>
               &quot;- At least 8 characters\n&quot; +                      // حداقل 8 کاراکتر
               &quot;- At least one uppercase letter (A-Z)\n&quot; +        // حداقل یک حرف بزرگ
               &quot;- At least one lowercase letter (a-z)\n&quot; +        // حداقل یک حرف کوچک
               &quot;- At least one digit (0-9)\n&quot; +                   // حداقل یک عدد
               &quot;- At least one special character (@#$%^&amp;+=)\n&quot; +   // حداقل یک کاراکتر خاص
               &quot;- No whitespace characters&quot;;                      // بدون فضای خالی
    }
    
    /**
     * تولید رمز عبور امن تصادفی
     * این متد رمز عبور قوی با طول مشخص تولید می‌کند
     * 
     * @param length طول رمز عبور مورد نظر (حداقل 8 کاراکتر)
     * @return رمز عبور تصادفی که الزامات قدرت را برآورده می‌کند
     */
    public static String generateSecurePassword(int length) {
<span class="fc bfc" id="L165" title="All 2 branches covered.">        if (length &lt; 8) {</span>
<span class="fc" id="L166">            length = 8; // حداقل طول 8 کاراکتر</span>
        }
        
        // مجموعه کاراکترهای مختلف
<span class="fc" id="L170">        String upperCase = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;    // حروف بزرگ انگلیسی</span>
<span class="fc" id="L171">        String lowerCase = &quot;abcdefghijklmnopqrstuvwxyz&quot;;    // حروف کوچک انگلیسی</span>
<span class="fc" id="L172">        String digits = &quot;0123456789&quot;;                       // اعداد</span>
<span class="fc" id="L173">        String specialChars = &quot;@#$%^&amp;+=&quot;;                   // کاراکترهای خاص</span>
<span class="fc" id="L174">        String allChars = upperCase + lowerCase + digits + specialChars; // همه کاراکترها</span>
        
<span class="fc" id="L176">        StringBuilder password = new StringBuilder();</span>
        
        // اطمینان از وجود حداقل یک کاراکتر از هر دسته الزامی
<span class="fc" id="L179">        password.append(upperCase.charAt(random.nextInt(upperCase.length())));</span>
<span class="fc" id="L180">        password.append(lowerCase.charAt(random.nextInt(lowerCase.length())));</span>
<span class="fc" id="L181">        password.append(digits.charAt(random.nextInt(digits.length())));</span>
<span class="fc" id="L182">        password.append(specialChars.charAt(random.nextInt(specialChars.length())));</span>
        
        // پر کردن بقیه طول با کاراکترهای تصادفی
<span class="fc bfc" id="L185" title="All 2 branches covered.">        for (int i = 4; i &lt; length; i++) {</span>
<span class="fc" id="L186">            password.append(allChars.charAt(random.nextInt(allChars.length())));</span>
        }
        
        // به هم ریختن ترتیب کاراکترها برای جلوگیری از الگوهای قابل پیش‌بینی
<span class="fc" id="L190">        return shuffleString(password.toString());</span>
    }
    
    /**
     * به هم ریختن کاراکترهای یک رشته
     * این متد الگوریتم Fisher-Yates برای shuffle استفاده می‌کند
     * 
     * @param input رشته ورودی برای به هم ریختن
     * @return رشته با کاراکترهای به هم ریخته
     */
    private static String shuffleString(String input) {
<span class="fc" id="L201">        char[] chars = input.toCharArray(); // تبدیل رشته به آرایه کاراکتر</span>
        
        // الگوریتم Fisher-Yates برای shuffle تصادفی
<span class="fc bfc" id="L204" title="All 2 branches covered.">        for (int i = chars.length - 1; i &gt; 0; i--) {</span>
<span class="fc" id="L205">            int j = random.nextInt(i + 1); // انتخاب ایندکس تصادفی</span>
            
            // جابجایی chars[i] و chars[j]
<span class="fc" id="L208">            char temp = chars[i];</span>
<span class="fc" id="L209">            chars[i] = chars[j];</span>
<span class="fc" id="L210">            chars[j] = temp;</span>
        }
        
<span class="fc" id="L213">        return new String(chars); // تبدیل آرایه به رشته</span>
    }
    
    /**
     * بررسی نیاز به hash مجدد رمز عبور (برای ارتقاء امنیتی)
     * در حال حاضر همیشه false برمی‌گرداند، اما می‌تواند برای تغییرات الگوریتم توسعه یابد
     * 
     * @param hashedPassword رمز عبور hash شده برای بررسی
     * @return true اگر نیاز به hash مجدد باشد، در غیر اینصورت false
     */
    public static boolean needsRehash(String hashedPassword) {
        // در نسخه‌های آینده، می‌تواند بررسی کند که آیا hash با الگوریتم‌های قدیمی ایجاد شده
<span class="fc" id="L225">        return false;</span>
    }
    
    /**
     * دریافت امتیاز قدرت رمز عبور (0-5)
     * این متد قدرت رمز عبور را بر اساس معیارهای مختلف ارزیابی می‌کند
     * 
     * @param password رمز عبور برای ارزیابی
     * @return امتیاز قدرت: 0=خیلی ضعیف، 1=ضعیف، 2=متوسط، 3=خوب، 4=قوی، 5=خیلی قوی
     */
    public static int getPasswordStrength(String password) {
<span class="fc bfc" id="L236" title="All 4 branches covered.">        if (password == null || password.isEmpty()) {</span>
<span class="fc" id="L237">            return 0; // رمز عبور خالی یا null</span>
        }
        
<span class="fc" id="L240">        int score = 0;</span>
        
        // بررسی طول رمز عبور
<span class="fc bfc" id="L243" title="All 2 branches covered.">        if (password.length() &gt;= 8) score++;   // امتیاز برای طول حداقل 8</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">        if (password.length() &gt;= 12) score++;  // امتیاز اضافی برای طول 12+</span>
        
        // بررسی تنوع کاراکترها
<span class="pc bpc" id="L247" title="1 of 2 branches missed.">        if (password.matches(&quot;.*[a-z].*&quot;)) score++; // حروف کوچک</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (password.matches(&quot;.*[A-Z].*&quot;)) score++; // حروف بزرگ</span>
<span class="fc bfc" id="L249" title="All 2 branches covered.">        if (password.matches(&quot;.*[0-9].*&quot;)) score++; // اعداد</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">        if (password.matches(&quot;.*[@#$%^&amp;+=!*].*&quot;)) score++; // کاراکترهای خاص</span>
        
        // کاهش امتیاز برای الگوهای رایج و ضعیف
<span class="fc bfc" id="L253" title="All 4 branches covered.">        if (password.matches(&quot;.*123.*&quot;) || password.matches(&quot;.*abc.*&quot;) || </span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">            password.toLowerCase().contains(&quot;password&quot;)) {</span>
<span class="fc" id="L255">            score = Math.max(0, score - 1); // کاهش یک امتیاز (حداقل 0)</span>
        }
        
<span class="fc" id="L258">        return Math.min(5, score); // حداکثر امتیاز 5</span>
    }
    
    /**
     * دریافت توضیح قدرت رمز عبور به صورت متنی
     * این متد امتیاز عددی قدرت را به توضیح فارسی تبدیل می‌کند
     * 
     * @param strength امتیاز قدرت رمز عبور (0-5)
     * @return توضیح فارسی قدرت رمز عبور
     */
    public static String getPasswordStrengthDescription(int strength) {
<span class="fc bfc" id="L269" title="All 7 branches covered.">        switch (strength) {</span>
<span class="fc" id="L270">            case 0: return &quot;خیلی ضعیف&quot;;     // Very Weak</span>
<span class="fc" id="L271">            case 1: return &quot;ضعیف&quot;;         // Weak</span>
<span class="fc" id="L272">            case 2: return &quot;متوسط&quot;;        // Fair</span>
<span class="fc" id="L273">            case 3: return &quot;خوب&quot;;          // Good</span>
<span class="fc" id="L274">            case 4: return &quot;قوی&quot;;          // Strong</span>
<span class="fc" id="L275">            case 5: return &quot;خیلی قوی&quot;;     // Very Strong</span>
<span class="fc" id="L276">            default: return &quot;نامشخص&quot;;      // Unknown</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>