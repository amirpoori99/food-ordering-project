<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AdvancedSecurityUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Food Ordering Backend</a> &gt; <a href="index.source.html" class="el_package">com.myapp.common.utils</a> &gt; <span class="el_source">AdvancedSecurityUtil.java</span></div><h1>AdvancedSecurityUtil.java</h1><pre class="source lang-java linenums">package com.myapp.common.utils;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.regex.Pattern;
import java.util.HashMap;

/**
 * کلاس ابزاری امنیت پیشرفته
 * این کلاس قابلیت‌های امنیتی پیشرفته‌تری را فراهم می‌کند:
 * - رمزنگاری و هش کردن
 * - ثبت وقایع امنیتی
 * - تشخیص تهدیدات پیشرفته
 * - مدیریت session های امن
 * - تولید کلیدهای امن
 * 
 * @author Food Ordering System Team
 * @version 1.0
 * @since 2024
 */
<span class="nc" id="L31">public class AdvancedSecurityUtil {</span>
    
    // ===== Configuration =====
    private static final String HASH_ALGORITHM = &quot;SHA-256&quot;;
    private static final String SALT_ALGORITHM = &quot;SHA1PRNG&quot;;
    private static final int SALT_LENGTH = 32;
    private static final int SESSION_ID_LENGTH = 64;
    private static final int MAX_SESSIONS_PER_USER = 5;
    private static final long SESSION_TIMEOUT_HOURS = 24;
    
    // ===== Threat Detection Patterns =====
<span class="fc" id="L42">    private static final Pattern SQL_INJECTION_PATTERN = Pattern.compile(</span>
        &quot;\\b(union|select|insert|update|delete|drop|create|alter|exec|execute|script)\\b&quot;, 
        Pattern.CASE_INSENSITIVE
    );
<span class="fc" id="L46">    private static final Pattern XSS_PATTERN = Pattern.compile(</span>
        &quot;&lt;script[^&gt;]*&gt;.*?&lt;/script&gt;|&lt;[^&gt;]*javascript:|on\\w+\\s*=&quot;, 
        Pattern.CASE_INSENSITIVE
    );
<span class="fc" id="L50">    private static final Pattern PATH_TRAVERSAL_PATTERN = Pattern.compile(</span>
        &quot;\\.\\./|\\.\\\\|%2e%2e%2f|%2e%2e%5c&quot;, 
        Pattern.CASE_INSENSITIVE
    );
    
    // ===== Storage =====
<span class="fc" id="L56">    private static final Map&lt;String, SessionInfo&gt; activeSessions = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L57">    private static final Map&lt;String, AtomicLong&gt; userSessionCounts = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L58">    private static final List&lt;SecurityEvent&gt; securityEvents = new CopyOnWriteArrayList&lt;&gt;();</span>
<span class="fc" id="L59">    private static final Map&lt;String, ThreatInfo&gt; threatTracker = new ConcurrentHashMap&lt;&gt;();</span>
    
    // ===== Secure Random Generator =====
<span class="fc" id="L62">    private static final SecureRandom secureRandom = new SecureRandom();</span>
    
    /**
     * کلاس اطلاعات session
     */
    private static class SessionInfo {
        private final String sessionId;
        private final Long userId;
        private final String userAgent;
        private final String ipAddress;
        private final LocalDateTime createdAt;
        private volatile LocalDateTime lastAccessed;
        
<span class="fc" id="L75">        public SessionInfo(String sessionId, Long userId, String userAgent, String ipAddress) {</span>
<span class="fc" id="L76">            this.sessionId = sessionId;</span>
<span class="fc" id="L77">            this.userId = userId;</span>
<span class="fc" id="L78">            this.userAgent = userAgent;</span>
<span class="fc" id="L79">            this.ipAddress = ipAddress;</span>
<span class="fc" id="L80">            this.createdAt = LocalDateTime.now();</span>
<span class="fc" id="L81">            this.lastAccessed = LocalDateTime.now();</span>
<span class="fc" id="L82">        }</span>
        
        public boolean isExpired() {
<span class="fc" id="L85">            return LocalDateTime.now().isAfter(lastAccessed.plusHours(SESSION_TIMEOUT_HOURS));</span>
        }
        
        public void updateLastAccessed() {
<span class="fc" id="L89">            this.lastAccessed = LocalDateTime.now();</span>
<span class="fc" id="L90">        }</span>
        
        // Getters
<span class="nc" id="L93">        public String getSessionId() { return sessionId; }</span>
<span class="fc" id="L94">        public Long getUserId() { return userId; }</span>
<span class="nc" id="L95">        public String getUserAgent() { return userAgent; }</span>
<span class="nc" id="L96">        public String getIpAddress() { return ipAddress; }</span>
<span class="nc" id="L97">        public LocalDateTime getCreatedAt() { return createdAt; }</span>
<span class="nc" id="L98">        public LocalDateTime getLastAccessed() { return lastAccessed; }</span>
    }
    
    /**
     * کلاس اطلاعات تهدید
     */
    private static class ThreatInfo {
        private final String identifier;
        private final String threatType;
        private final LocalDateTime firstDetected;
        private final AtomicLong occurrenceCount;
        private volatile LocalDateTime lastDetected;
        
<span class="fc" id="L111">        public ThreatInfo(String identifier, String threatType) {</span>
<span class="fc" id="L112">            this.identifier = identifier;</span>
<span class="fc" id="L113">            this.threatType = threatType;</span>
<span class="fc" id="L114">            this.firstDetected = LocalDateTime.now();</span>
<span class="fc" id="L115">            this.lastDetected = LocalDateTime.now();</span>
<span class="fc" id="L116">            this.occurrenceCount = new AtomicLong(1);</span>
<span class="fc" id="L117">        }</span>
        
        public void incrementOccurrence() {
<span class="fc" id="L120">            occurrenceCount.incrementAndGet();</span>
<span class="fc" id="L121">            lastDetected = LocalDateTime.now();</span>
<span class="fc" id="L122">        }</span>
        
        // Getters
<span class="nc" id="L125">        public String getIdentifier() { return identifier; }</span>
<span class="fc" id="L126">        public String getThreatType() { return threatType; }</span>
<span class="nc" id="L127">        public LocalDateTime getFirstDetected() { return firstDetected; }</span>
<span class="fc" id="L128">        public LocalDateTime getLastDetected() { return lastDetected; }</span>
<span class="nc" id="L129">        public long getOccurrenceCount() { return occurrenceCount.get(); }</span>
    }
    
    /**
     * کلاس رویداد امنیتی
     */
    public static class SecurityEvent {
        private final String eventType;
        private final String description;
        private final String identifier;
        private final String severity;
        private final LocalDateTime timestamp;
        private final Map&lt;String, Object&gt; details;
        
        public SecurityEvent(String eventType, String description, String identifier, 
<span class="fc" id="L144">                           String severity, Map&lt;String, Object&gt; details) {</span>
<span class="fc" id="L145">            this.eventType = eventType;</span>
<span class="fc" id="L146">            this.description = description;</span>
<span class="fc" id="L147">            this.identifier = identifier;</span>
<span class="fc" id="L148">            this.severity = severity;</span>
<span class="fc" id="L149">            this.timestamp = LocalDateTime.now();</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">            this.details = details != null ? new HashMap&lt;&gt;(details) : new HashMap&lt;&gt;();</span>
<span class="fc" id="L151">        }</span>
        
        // Getters
<span class="fc" id="L154">        public String getEventType() { return eventType; }</span>
<span class="fc" id="L155">        public String getDescription() { return description; }</span>
<span class="fc" id="L156">        public String getIdentifier() { return identifier; }</span>
<span class="fc" id="L157">        public String getSeverity() { return severity; }</span>
<span class="fc" id="L158">        public LocalDateTime getTimestamp() { return timestamp; }</span>
<span class="fc" id="L159">        public Map&lt;String, Object&gt; getDetails() { return new HashMap&lt;&gt;(details); }</span>
        
        @Override
        public String toString() {
<span class="fc" id="L163">            return String.format(&quot;[%s] %s - %s (%s) - %s&quot;, </span>
<span class="fc" id="L164">                timestamp.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME),</span>
                severity, eventType, identifier, description);
        }
    }
    
    // ===== Hashing and Encryption Methods =====
    
    /**
     * تولید salt تصادفی
     * 
     * @return salt به صورت Base64
     */
    public static String generateSalt() {
<span class="fc" id="L177">        byte[] salt = new byte[SALT_LENGTH];</span>
<span class="fc" id="L178">        secureRandom.nextBytes(salt);</span>
<span class="fc" id="L179">        return Base64.getEncoder().encodeToString(salt);</span>
    }
    
    /**
     * هش کردن متن با salt
     * 
     * @param text متن برای هش کردن
     * @param salt salt برای اضافه کردن
     * @return هش SHA-256
     */
    public static String hashWithSalt(String text, String salt) {
<span class="fc bfc" id="L190" title="All 4 branches covered.">        if (text == null || salt == null) {</span>
<span class="fc" id="L191">            throw new IllegalArgumentException(&quot;Text and salt cannot be null&quot;);</span>
        }
        
        try {
<span class="fc" id="L195">            MessageDigest digest = MessageDigest.getInstance(HASH_ALGORITHM);</span>
<span class="fc" id="L196">            String combined = text + salt;</span>
<span class="fc" id="L197">            byte[] hash = digest.digest(combined.getBytes());</span>
<span class="fc" id="L198">            return Base64.getEncoder().encodeToString(hash);</span>
<span class="nc" id="L199">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L200">            throw new RuntimeException(&quot;Hash algorithm not available&quot;, e);</span>
        }
    }
    
    /**
     * تولید هش امن برای رمز عبور
     * 
     * @param password رمز عبور
     * @return Map شامل هش و salt
     */
    public static Map&lt;String, String&gt; hashPassword(String password) {
<span class="fc bfc" id="L211" title="All 4 branches covered.">        if (password == null || password.trim().isEmpty()) {</span>
<span class="fc" id="L212">            throw new IllegalArgumentException(&quot;Password cannot be null or empty&quot;);</span>
        }
        
<span class="fc" id="L215">        String salt = generateSalt();</span>
<span class="fc" id="L216">        String hash = hashWithSalt(password, salt);</span>
        
<span class="fc" id="L218">        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();</span>
<span class="fc" id="L219">        result.put(&quot;hash&quot;, hash);</span>
<span class="fc" id="L220">        result.put(&quot;salt&quot;, salt);</span>
<span class="fc" id="L221">        return result;</span>
    }
    
    /**
     * بررسی رمز عبور
     * 
     * @param password رمز عبور
     * @param storedHash هش ذخیره شده
     * @param storedSalt salt ذخیره شده
     * @return true اگر رمز عبور صحیح باشد
     */
    public static boolean verifyPassword(String password, String storedHash, String storedSalt) {
<span class="pc bpc" id="L233" title="3 of 6 branches missed.">        if (password == null || storedHash == null || storedSalt == null) {</span>
<span class="nc" id="L234">            return false;</span>
        }
        
<span class="fc" id="L237">        String computedHash = hashWithSalt(password, storedSalt);</span>
<span class="fc" id="L238">        return storedHash.equals(computedHash);</span>
    }
    
    // ===== Session Management Methods =====
    
    /**
     * ایجاد session جدید
     * 
     * @param userId شناسه کاربر
     * @param userAgent User-Agent
     * @param ipAddress آدرس IP
     * @return شناسه session یا null اگر محدودیت تجاوز شود
     */
    public static String createSession(Long userId, String userAgent, String ipAddress) {
<span class="fc bfc" id="L252" title="All 2 branches covered.">        if (userId == null) {</span>
<span class="fc" id="L253">            throw new IllegalArgumentException(&quot;User ID cannot be null&quot;);</span>
        }
        
        // بررسی محدودیت session
<span class="fc" id="L257">        AtomicLong sessionCount = userSessionCounts.computeIfAbsent(userId.toString(), k -&gt; new AtomicLong(0));</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">        if (sessionCount.get() &gt;= MAX_SESSIONS_PER_USER) {</span>
<span class="fc" id="L259">            logSecurityEvent(&quot;SESSION_LIMIT_EXCEEDED&quot;, </span>
                &quot;User exceeded maximum session limit&quot;, 
<span class="fc" id="L261">                userId.toString(), &quot;WARNING&quot;, </span>
<span class="fc" id="L262">                Map.of(&quot;userId&quot;, userId, &quot;sessionCount&quot;, sessionCount.get()));</span>
<span class="fc" id="L263">            return null;</span>
        }
        
        // تولید session ID امن
<span class="fc" id="L267">        String sessionId = generateSecureSessionId();</span>
        
        // ایجاد session
<span class="fc" id="L270">        SessionInfo sessionInfo = new SessionInfo(sessionId, userId, userAgent, ipAddress);</span>
<span class="fc" id="L271">        activeSessions.put(sessionId, sessionInfo);</span>
<span class="fc" id="L272">        sessionCount.incrementAndGet();</span>
        
<span class="fc" id="L274">        logSecurityEvent(&quot;SESSION_CREATED&quot;, </span>
            &quot;New session created&quot;, 
<span class="fc" id="L276">            userId.toString(), &quot;INFO&quot;, </span>
<span class="fc" id="L277">            Map.of(&quot;userId&quot;, userId, &quot;sessionId&quot;, sessionId, &quot;ipAddress&quot;, ipAddress));</span>
        
<span class="fc" id="L279">        return sessionId;</span>
    }
    
    /**
     * اعتبارسنجی session
     * 
     * @param sessionId شناسه session
     * @return true اگر session معتبر باشد
     */
    public static boolean validateSession(String sessionId) {
<span class="pc bpc" id="L289" title="1 of 4 branches missed.">        if (sessionId == null || sessionId.trim().isEmpty()) {</span>
<span class="fc" id="L290">            return false;</span>
        }
        
<span class="fc" id="L293">        SessionInfo sessionInfo = activeSessions.get(sessionId);</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">        if (sessionInfo == null) {</span>
<span class="fc" id="L295">            return false;</span>
        }
        
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        if (sessionInfo.isExpired()) {</span>
<span class="nc" id="L299">            removeSession(sessionId);</span>
<span class="nc" id="L300">            return false;</span>
        }
        
<span class="fc" id="L303">        sessionInfo.updateLastAccessed();</span>
<span class="fc" id="L304">        return true;</span>
    }
    
    /**
     * حذف session
     * 
     * @param sessionId شناسه session
     */
    public static void removeSession(String sessionId) {
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (sessionId == null) return;</span>
        
<span class="fc" id="L315">        SessionInfo sessionInfo = activeSessions.remove(sessionId);</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        if (sessionInfo != null) {</span>
<span class="fc" id="L317">            String userId = sessionInfo.getUserId().toString();</span>
<span class="fc" id="L318">            AtomicLong sessionCount = userSessionCounts.get(userId);</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">            if (sessionCount != null) {</span>
<span class="fc" id="L320">                sessionCount.decrementAndGet();</span>
            }
            
<span class="fc" id="L323">            logSecurityEvent(&quot;SESSION_REMOVED&quot;, </span>
                &quot;Session removed&quot;, 
                userId, &quot;INFO&quot;, 
<span class="fc" id="L326">                Map.of(&quot;userId&quot;, sessionInfo.getUserId(), &quot;sessionId&quot;, sessionId));</span>
        }
<span class="fc" id="L328">    }</span>
    
    /**
     * پاک‌سازی session های منقضی شده
     */
    public static void cleanupExpiredSessions() {
<span class="fc" id="L334">        List&lt;String&gt; expiredSessions = new ArrayList&lt;&gt;();</span>
        
<span class="fc bfc" id="L336" title="All 2 branches covered.">        for (Map.Entry&lt;String, SessionInfo&gt; entry : activeSessions.entrySet()) {</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">            if (entry.getValue().isExpired()) {</span>
<span class="nc" id="L338">                expiredSessions.add(entry.getKey());</span>
            }
<span class="fc" id="L340">        }</span>
        
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">        for (String sessionId : expiredSessions) {</span>
<span class="nc" id="L343">            removeSession(sessionId);</span>
<span class="nc" id="L344">        }</span>
        
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">        if (!expiredSessions.isEmpty()) {</span>
<span class="nc" id="L347">            logSecurityEvent(&quot;SESSIONS_CLEANUP&quot;, </span>
<span class="nc" id="L348">                &quot;Cleaned up &quot; + expiredSessions.size() + &quot; expired sessions&quot;, </span>
                &quot;SYSTEM&quot;, &quot;INFO&quot;, 
<span class="nc" id="L350">                Map.of(&quot;expiredCount&quot;, expiredSessions.size()));</span>
        }
<span class="fc" id="L352">    }</span>
    
    // ===== Threat Detection Methods =====
    
    /**
     * تشخیص تهدیدات در ورودی
     * 
     * @param input ورودی برای بررسی
     * @param identifier شناسه منبع (IP، userId، etc.)
     * @return true اگر تهدید تشخیص داده شود
     */
    public static boolean detectThreats(String input, String identifier) {
<span class="fc bfc" id="L364" title="All 4 branches covered.">        if (input == null || identifier == null) {</span>
<span class="fc" id="L365">            return false;</span>
        }
        
<span class="fc" id="L368">        boolean threatDetected = false;</span>
<span class="fc" id="L369">        String threatType = null;</span>
        
        // بررسی SQL Injection
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (SQL_INJECTION_PATTERN.matcher(input).find()) {</span>
<span class="fc" id="L373">            threatDetected = true;</span>
<span class="fc" id="L374">            threatType = &quot;SQL_INJECTION&quot;;</span>
        }
        
        // بررسی XSS
<span class="fc bfc" id="L378" title="All 2 branches covered.">        if (XSS_PATTERN.matcher(input).find()) {</span>
<span class="fc" id="L379">            threatDetected = true;</span>
<span class="fc" id="L380">            threatType = &quot;XSS&quot;;</span>
        }
        
        // بررسی Path Traversal
<span class="fc bfc" id="L384" title="All 2 branches covered.">        if (PATH_TRAVERSAL_PATTERN.matcher(input).find()) {</span>
<span class="fc" id="L385">            threatDetected = true;</span>
<span class="fc" id="L386">            threatType = &quot;PATH_TRAVERSAL&quot;;</span>
        }
        
<span class="fc bfc" id="L389" title="All 2 branches covered.">        if (threatDetected) {</span>
<span class="fc" id="L390">            recordThreat(identifier, threatType, input);</span>
<span class="fc" id="L391">            logSecurityEvent(&quot;THREAT_DETECTED&quot;, </span>
                &quot;Security threat detected: &quot; + threatType, 
                identifier, &quot;HIGH&quot;, 
<span class="fc" id="L394">                Map.of(&quot;threatType&quot;, threatType, &quot;input&quot;, input));</span>
        }
        
<span class="fc" id="L397">        return threatDetected;</span>
    }
    
    /**
     * ثبت تهدید
     * 
     * @param identifier شناسه منبع
     * @param threatType نوع تهدید
     * @param details جزئیات تهدید
     */
    private static void recordThreat(String identifier, String threatType, String details) {
<span class="fc" id="L408">        String key = identifier + &quot;:&quot; + threatType;</span>
<span class="fc" id="L409">        ThreatInfo threatInfo = threatTracker.computeIfAbsent(key, k -&gt; new ThreatInfo(identifier, threatType));</span>
<span class="fc" id="L410">        threatInfo.incrementOccurrence();</span>
<span class="fc" id="L411">    }</span>
    
    // ===== Security Event Logging =====
    
    /**
     * ثبت رویداد امنیتی
     * 
     * @param eventType نوع رویداد
     * @param description توضیحات
     * @param identifier شناسه
     * @param severity سطح اهمیت (INFO, WARNING, HIGH, CRITICAL)
     * @param details جزئیات اضافی
     */
    public static void logSecurityEvent(String eventType, String description, String identifier, 
                                      String severity, Map&lt;String, Object&gt; details) {
<span class="fc" id="L426">        SecurityEvent event = new SecurityEvent(eventType, description, identifier, severity, details);</span>
<span class="fc" id="L427">        securityEvents.add(event);</span>
        
        // چاپ در console برای debugging
<span class="fc" id="L430">        System.out.println(&quot;🔒 Security Event: &quot; + event.toString());</span>
        
        // اگر رویداد بحرانی است، اقدامات اضافی انجام دهید
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">        if (&quot;CRITICAL&quot;.equals(severity)) {</span>
<span class="nc" id="L434">            handleCriticalEvent(event);</span>
        }
<span class="fc" id="L436">    }</span>
    
    /**
     * مدیریت رویدادهای بحرانی
     * 
     * @param event رویداد بحرانی
     */
    private static void handleCriticalEvent(SecurityEvent event) {
        // در اینجا می‌توانید اقدامات اضافی مانند:
        // - ارسال هشدار به مدیر سیستم
        // - مسدود کردن IP
        // - ثبت در فایل لاگ جداگانه
        // - ارسال ایمیل هشدار
        
<span class="nc" id="L450">        System.err.println(&quot;🚨 CRITICAL SECURITY EVENT: &quot; + event.getDescription());</span>
<span class="nc" id="L451">    }</span>
    
    /**
     * دریافت رویدادهای امنیتی
     * 
     * @param limit تعداد رویدادهای بازگشتی
     * @return لیست رویدادها
     */
    public static List&lt;SecurityEvent&gt; getSecurityEvents(int limit) {
<span class="fc" id="L460">        int size = securityEvents.size();</span>
<span class="fc" id="L461">        int startIndex = Math.max(0, size - limit);</span>
<span class="fc" id="L462">        return new ArrayList&lt;&gt;(securityEvents.subList(startIndex, size));</span>
    }
    
    /**
     * دریافت آمار تهدیدات
     * 
     * @return Map شامل آمار تهدیدات
     */
    public static Map&lt;String, Object&gt; getThreatStatistics() {
<span class="fc" id="L471">        Map&lt;String, Object&gt; stats = new HashMap&lt;&gt;();</span>
<span class="fc" id="L472">        stats.put(&quot;totalThreats&quot;, threatTracker.size());</span>
<span class="fc" id="L473">        stats.put(&quot;activeSessions&quot;, activeSessions.size());</span>
<span class="fc" id="L474">        stats.put(&quot;securityEvents&quot;, securityEvents.size());</span>
        
        // آمار تهدیدات بر اساس نوع
<span class="fc" id="L477">        Map&lt;String, Long&gt; threatTypeCounts = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">        for (ThreatInfo threat : threatTracker.values()) {</span>
<span class="fc" id="L479">            threatTypeCounts.merge(threat.getThreatType(), 1L, Long::sum);</span>
<span class="fc" id="L480">        }</span>
<span class="fc" id="L481">        stats.put(&quot;threatTypeCounts&quot;, threatTypeCounts);</span>
        
<span class="fc" id="L483">        return stats;</span>
    }
    
    // ===== Utility Methods =====
    
    /**
     * تولید شناسه session امن
     * 
     * @return شناسه session
     */
    private static String generateSecureSessionId() {
<span class="fc" id="L494">        byte[] randomBytes = new byte[SESSION_ID_LENGTH];</span>
<span class="fc" id="L495">        secureRandom.nextBytes(randomBytes);</span>
<span class="fc" id="L496">        return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);</span>
    }
    
    /**
     * تولید کلید تصادفی امن
     * 
     * @param length طول کلید
     * @return کلید تصادفی
     */
    public static String generateSecureKey(int length) {
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">        if (length &lt;= 0) length = 32;</span>
        
<span class="fc" id="L508">        byte[] keyBytes = new byte[length];</span>
<span class="fc" id="L509">        secureRandom.nextBytes(keyBytes);</span>
<span class="fc" id="L510">        return Base64.getUrlEncoder().withoutPadding().encodeToString(keyBytes);</span>
    }
    
    /**
     * بررسی امنیت فایل
     * 
     * @param filename نام فایل
     * @return true اگر فایل امن باشد
     */
    public static boolean isSecureFilename(String filename) {
<span class="fc bfc" id="L520" title="All 4 branches covered.">        if (filename == null || filename.trim().isEmpty()) {</span>
<span class="fc" id="L521">            return false;</span>
        }
        
        // بررسی پسوندهای خطرناک
<span class="fc" id="L525">        String lowerFilename = filename.toLowerCase();</span>
<span class="fc" id="L526">        String[] dangerousExtensions = {&quot;.exe&quot;, &quot;.bat&quot;, &quot;.cmd&quot;, &quot;.com&quot;, &quot;.pif&quot;, &quot;.scr&quot;, &quot;.vbs&quot;, &quot;.js&quot;};</span>
        
<span class="fc bfc" id="L528" title="All 2 branches covered.">        for (String ext : dangerousExtensions) {</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">            if (lowerFilename.endsWith(ext)) {</span>
<span class="fc" id="L530">                return false;</span>
            }
        }
        
        // بررسی کاراکترهای خطرناک
<span class="fc bfc" id="L535" title="All 2 branches covered.">        return !filename.contains(&quot;..&quot;) &amp;&amp; </span>
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">               !filename.contains(&quot;\\&quot;) &amp;&amp; </span>
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">               !filename.contains(&quot;/&quot;) &amp;&amp;</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">               !filename.contains(&quot;:&quot;) &amp;&amp;</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">               !filename.contains(&quot;*&quot;) &amp;&amp;</span>
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">               !filename.contains(&quot;?&quot;) &amp;&amp;</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">               !filename.contains(&quot;\&quot;&quot;) &amp;&amp;</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">               !filename.contains(&quot;&lt;&quot;) &amp;&amp;</span>
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">               !filename.contains(&quot;&gt;&quot;) &amp;&amp;</span>
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">               !filename.contains(&quot;|&quot;);</span>
    }
    
    /**
     * پاک‌سازی داده‌های قدیمی
     */
    public static void cleanupOldData() {
        // پاک‌سازی session های منقضی شده
<span class="fc" id="L552">        cleanupExpiredSessions();</span>
        
        // پاک‌سازی رویدادهای قدیمی (بیش از 30 روز)
<span class="fc" id="L555">        LocalDateTime cutoffEvents = LocalDateTime.now().minusDays(30);</span>
<span class="fc" id="L556">        securityEvents.removeIf(event -&gt; event.getTimestamp().isBefore(cutoffEvents));</span>
        
        // پاک‌سازی تهدیدات قدیمی (بیش از 7 روز)
<span class="fc" id="L559">        LocalDateTime cutoffThreats = LocalDateTime.now().minusDays(7);</span>
<span class="fc" id="L560">        threatTracker.entrySet().removeIf(entry -&gt; </span>
<span class="fc" id="L561">            entry.getValue().getLastDetected().isBefore(cutoffThreats));</span>
<span class="fc" id="L562">    }</span>
} 
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>