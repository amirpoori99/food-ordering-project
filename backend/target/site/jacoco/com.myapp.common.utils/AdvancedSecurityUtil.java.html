<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AdvancedSecurityUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Food Ordering Backend</a> &gt; <a href="index.source.html" class="el_package">com.myapp.common.utils</a> &gt; <span class="el_source">AdvancedSecurityUtil.java</span></div><h1>AdvancedSecurityUtil.java</h1><pre class="source lang-java linenums">package com.myapp.common.utils;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.regex.Pattern;
import java.util.HashMap;

/**
 * Ú©Ù„Ø§Ø³ Ø§Ø¨Ø²Ø§Ø±ÛŒ Ø§Ù…Ù†ÛŒØª Ù¾ÛŒØ´Ø±ÙØªÙ‡
 * Ø§ÛŒÙ† Ú©Ù„Ø§Ø³ Ù‚Ø§Ø¨Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø§Ù…Ù†ÛŒØªÛŒ Ù¾ÛŒØ´Ø±ÙØªÙ‡â€ŒØªØ±ÛŒ Ø±Ø§ ÙØ±Ø§Ù‡Ù… Ù…ÛŒâ€ŒÚ©Ù†Ø¯:
 * - Ø±Ù…Ø²Ù†Ú¯Ø§Ø±ÛŒ Ùˆ Ù‡Ø´ Ú©Ø±Ø¯Ù†
 * - Ø«Ø¨Øª ÙˆÙ‚Ø§ÛŒØ¹ Ø§Ù…Ù†ÛŒØªÛŒ
 * - ØªØ´Ø®ÛŒØµ ØªÙ‡Ø¯ÛŒØ¯Ø§Øª Ù¾ÛŒØ´Ø±ÙØªÙ‡
 * - Ù…Ø¯ÛŒØ±ÛŒØª session Ù‡Ø§ÛŒ Ø§Ù…Ù†
 * - ØªÙˆÙ„ÛŒØ¯ Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ Ø§Ù…Ù†
 * 
 * @author Food Ordering System Team
 * @version 1.0
 * @since 2024
 */
<span class="nc" id="L31">public class AdvancedSecurityUtil {</span>
    
    // ===== Configuration =====
    private static final String HASH_ALGORITHM = &quot;SHA-256&quot;;
    private static final String SALT_ALGORITHM = &quot;SHA1PRNG&quot;;
    private static final int SALT_LENGTH = 32;
    private static final int SESSION_ID_LENGTH = 64;
    private static final int MAX_SESSIONS_PER_USER = 5;
    private static final long SESSION_TIMEOUT_HOURS = 24;
    
    // ===== Threat Detection Patterns =====
<span class="fc" id="L42">    private static final Pattern SQL_INJECTION_PATTERN = Pattern.compile(</span>
        &quot;\\b(union|select|insert|update|delete|drop|create|alter|exec|execute|script)\\b&quot;, 
        Pattern.CASE_INSENSITIVE
    );
<span class="fc" id="L46">    private static final Pattern XSS_PATTERN = Pattern.compile(</span>
        &quot;&lt;script[^&gt;]*&gt;.*?&lt;/script&gt;|&lt;[^&gt;]*javascript:|on\\w+\\s*=&quot;, 
        Pattern.CASE_INSENSITIVE
    );
<span class="fc" id="L50">    private static final Pattern PATH_TRAVERSAL_PATTERN = Pattern.compile(</span>
        &quot;\\.\\./|\\.\\\\|%2e%2e%2f|%2e%2e%5c&quot;, 
        Pattern.CASE_INSENSITIVE
    );
    
    // ===== Storage =====
<span class="fc" id="L56">    private static final Map&lt;String, SessionInfo&gt; activeSessions = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L57">    private static final Map&lt;String, AtomicLong&gt; userSessionCounts = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L58">    private static final List&lt;SecurityEvent&gt; securityEvents = new CopyOnWriteArrayList&lt;&gt;();</span>
<span class="fc" id="L59">    private static final Map&lt;String, ThreatInfo&gt; threatTracker = new ConcurrentHashMap&lt;&gt;();</span>
    
    // ===== Secure Random Generator =====
<span class="fc" id="L62">    private static final SecureRandom secureRandom = new SecureRandom();</span>
    
    /**
     * Ú©Ù„Ø§Ø³ Ø§Ø·Ù„Ø§Ø¹Ø§Øª session
     */
    private static class SessionInfo {
        private final String sessionId;
        private final Long userId;
        private final String userAgent;
        private final String ipAddress;
        private final LocalDateTime createdAt;
        private volatile LocalDateTime lastAccessed;
        
<span class="fc" id="L75">        public SessionInfo(String sessionId, Long userId, String userAgent, String ipAddress) {</span>
<span class="fc" id="L76">            this.sessionId = sessionId;</span>
<span class="fc" id="L77">            this.userId = userId;</span>
<span class="fc" id="L78">            this.userAgent = userAgent;</span>
<span class="fc" id="L79">            this.ipAddress = ipAddress;</span>
<span class="fc" id="L80">            this.createdAt = LocalDateTime.now();</span>
<span class="fc" id="L81">            this.lastAccessed = LocalDateTime.now();</span>
<span class="fc" id="L82">        }</span>
        
        public boolean isExpired() {
<span class="fc" id="L85">            return LocalDateTime.now().isAfter(lastAccessed.plusHours(SESSION_TIMEOUT_HOURS));</span>
        }
        
        public void updateLastAccessed() {
<span class="fc" id="L89">            this.lastAccessed = LocalDateTime.now();</span>
<span class="fc" id="L90">        }</span>
        
        // Getters
<span class="nc" id="L93">        public String getSessionId() { return sessionId; }</span>
<span class="fc" id="L94">        public Long getUserId() { return userId; }</span>
<span class="nc" id="L95">        public String getUserAgent() { return userAgent; }</span>
<span class="nc" id="L96">        public String getIpAddress() { return ipAddress; }</span>
<span class="nc" id="L97">        public LocalDateTime getCreatedAt() { return createdAt; }</span>
<span class="nc" id="L98">        public LocalDateTime getLastAccessed() { return lastAccessed; }</span>
    }
    
    /**
     * Ú©Ù„Ø§Ø³ Ø§Ø·Ù„Ø§Ø¹Ø§Øª ØªÙ‡Ø¯ÛŒØ¯
     */
    private static class ThreatInfo {
        private final String identifier;
        private final String threatType;
        private final LocalDateTime firstDetected;
        private final AtomicLong occurrenceCount;
        private volatile LocalDateTime lastDetected;
        
<span class="fc" id="L111">        public ThreatInfo(String identifier, String threatType) {</span>
<span class="fc" id="L112">            this.identifier = identifier;</span>
<span class="fc" id="L113">            this.threatType = threatType;</span>
<span class="fc" id="L114">            this.firstDetected = LocalDateTime.now();</span>
<span class="fc" id="L115">            this.lastDetected = LocalDateTime.now();</span>
<span class="fc" id="L116">            this.occurrenceCount = new AtomicLong(1);</span>
<span class="fc" id="L117">        }</span>
        
        public void incrementOccurrence() {
<span class="fc" id="L120">            occurrenceCount.incrementAndGet();</span>
<span class="fc" id="L121">            lastDetected = LocalDateTime.now();</span>
<span class="fc" id="L122">        }</span>
        
        // Getters
<span class="nc" id="L125">        public String getIdentifier() { return identifier; }</span>
<span class="fc" id="L126">        public String getThreatType() { return threatType; }</span>
<span class="nc" id="L127">        public LocalDateTime getFirstDetected() { return firstDetected; }</span>
<span class="fc" id="L128">        public LocalDateTime getLastDetected() { return lastDetected; }</span>
<span class="nc" id="L129">        public long getOccurrenceCount() { return occurrenceCount.get(); }</span>
    }
    
    /**
     * Ú©Ù„Ø§Ø³ Ø±ÙˆÛŒØ¯Ø§Ø¯ Ø§Ù…Ù†ÛŒØªÛŒ
     */
    public static class SecurityEvent {
        private final String eventType;
        private final String description;
        private final String identifier;
        private final String severity;
        private final LocalDateTime timestamp;
        private final Map&lt;String, Object&gt; details;
        
        public SecurityEvent(String eventType, String description, String identifier, 
<span class="fc" id="L144">                           String severity, Map&lt;String, Object&gt; details) {</span>
<span class="fc" id="L145">            this.eventType = eventType;</span>
<span class="fc" id="L146">            this.description = description;</span>
<span class="fc" id="L147">            this.identifier = identifier;</span>
<span class="fc" id="L148">            this.severity = severity;</span>
<span class="fc" id="L149">            this.timestamp = LocalDateTime.now();</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">            this.details = details != null ? new HashMap&lt;&gt;(details) : new HashMap&lt;&gt;();</span>
<span class="fc" id="L151">        }</span>
        
        // Getters
<span class="fc" id="L154">        public String getEventType() { return eventType; }</span>
<span class="fc" id="L155">        public String getDescription() { return description; }</span>
<span class="fc" id="L156">        public String getIdentifier() { return identifier; }</span>
<span class="fc" id="L157">        public String getSeverity() { return severity; }</span>
<span class="fc" id="L158">        public LocalDateTime getTimestamp() { return timestamp; }</span>
<span class="fc" id="L159">        public Map&lt;String, Object&gt; getDetails() { return new HashMap&lt;&gt;(details); }</span>
        
        @Override
        public String toString() {
<span class="fc" id="L163">            return String.format(&quot;[%s] %s - %s (%s) - %s&quot;, </span>
<span class="fc" id="L164">                timestamp.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME),</span>
                severity, eventType, identifier, description);
        }
    }
    
    // ===== Hashing and Encryption Methods =====
    
    /**
     * ØªÙˆÙ„ÛŒØ¯ salt ØªØµØ§Ø¯ÙÛŒ
     * 
     * @return salt Ø¨Ù‡ ØµÙˆØ±Øª Base64
     */
    public static String generateSalt() {
<span class="fc" id="L177">        byte[] salt = new byte[SALT_LENGTH];</span>
<span class="fc" id="L178">        secureRandom.nextBytes(salt);</span>
<span class="fc" id="L179">        return Base64.getEncoder().encodeToString(salt);</span>
    }
    
    /**
     * Ù‡Ø´ Ú©Ø±Ø¯Ù† Ù…ØªÙ† Ø¨Ø§ salt
     * 
     * @param text Ù…ØªÙ† Ø¨Ø±Ø§ÛŒ Ù‡Ø´ Ú©Ø±Ø¯Ù†
     * @param salt salt Ø¨Ø±Ø§ÛŒ Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù†
     * @return Ù‡Ø´ SHA-256
     */
    public static String hashWithSalt(String text, String salt) {
<span class="fc bfc" id="L190" title="All 4 branches covered.">        if (text == null || salt == null) {</span>
<span class="fc" id="L191">            throw new IllegalArgumentException(&quot;Text and salt cannot be null&quot;);</span>
        }
        
        try {
<span class="fc" id="L195">            MessageDigest digest = MessageDigest.getInstance(HASH_ALGORITHM);</span>
<span class="fc" id="L196">            String combined = text + salt;</span>
<span class="fc" id="L197">            byte[] hash = digest.digest(combined.getBytes());</span>
<span class="fc" id="L198">            return Base64.getEncoder().encodeToString(hash);</span>
<span class="nc" id="L199">        } catch (NoSuchAlgorithmException e) {</span>
<span class="nc" id="L200">            throw new RuntimeException(&quot;Hash algorithm not available&quot;, e);</span>
        }
    }
    
    /**
     * ØªÙˆÙ„ÛŒØ¯ Ù‡Ø´ Ø§Ù…Ù† Ø¨Ø±Ø§ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±
     * 
     * @param password Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±
     * @return Map Ø´Ø§Ù…Ù„ Ù‡Ø´ Ùˆ salt
     */
    public static Map&lt;String, String&gt; hashPassword(String password) {
<span class="fc bfc" id="L211" title="All 4 branches covered.">        if (password == null || password.trim().isEmpty()) {</span>
<span class="fc" id="L212">            throw new IllegalArgumentException(&quot;Password cannot be null or empty&quot;);</span>
        }
        
<span class="fc" id="L215">        String salt = generateSalt();</span>
<span class="fc" id="L216">        String hash = hashWithSalt(password, salt);</span>
        
<span class="fc" id="L218">        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();</span>
<span class="fc" id="L219">        result.put(&quot;hash&quot;, hash);</span>
<span class="fc" id="L220">        result.put(&quot;salt&quot;, salt);</span>
<span class="fc" id="L221">        return result;</span>
    }
    
    /**
     * Ø¨Ø±Ø±Ø³ÛŒ Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±
     * 
     * @param password Ø±Ù…Ø² Ø¹Ø¨ÙˆØ±
     * @param storedHash Ù‡Ø´ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯Ù‡
     * @param storedSalt salt Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯Ù‡
     * @return true Ø§Ú¯Ø± Ø±Ù…Ø² Ø¹Ø¨ÙˆØ± ØµØ­ÛŒØ­ Ø¨Ø§Ø´Ø¯
     */
    public static boolean verifyPassword(String password, String storedHash, String storedSalt) {
<span class="pc bpc" id="L233" title="3 of 6 branches missed.">        if (password == null || storedHash == null || storedSalt == null) {</span>
<span class="nc" id="L234">            return false;</span>
        }
        
<span class="fc" id="L237">        String computedHash = hashWithSalt(password, storedSalt);</span>
<span class="fc" id="L238">        return storedHash.equals(computedHash);</span>
    }
    
    // ===== Session Management Methods =====
    
    /**
     * Ø§ÛŒØ¬Ø§Ø¯ session Ø¬Ø¯ÛŒØ¯
     * 
     * @param userId Ø´Ù†Ø§Ø³Ù‡ Ú©Ø§Ø±Ø¨Ø±
     * @param userAgent User-Agent
     * @param ipAddress Ø¢Ø¯Ø±Ø³ IP
     * @return Ø´Ù†Ø§Ø³Ù‡ session ÛŒØ§ null Ø§Ú¯Ø± Ù…Ø­Ø¯ÙˆØ¯ÛŒØª ØªØ¬Ø§ÙˆØ² Ø´ÙˆØ¯
     */
    public static String createSession(Long userId, String userAgent, String ipAddress) {
<span class="fc bfc" id="L252" title="All 2 branches covered.">        if (userId == null) {</span>
<span class="fc" id="L253">            throw new IllegalArgumentException(&quot;User ID cannot be null&quot;);</span>
        }
        
        // Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø­Ø¯ÙˆØ¯ÛŒØª session
<span class="fc" id="L257">        AtomicLong sessionCount = userSessionCounts.computeIfAbsent(userId.toString(), k -&gt; new AtomicLong(0));</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">        if (sessionCount.get() &gt;= MAX_SESSIONS_PER_USER) {</span>
<span class="fc" id="L259">            logSecurityEvent(&quot;SESSION_LIMIT_EXCEEDED&quot;, </span>
                &quot;User exceeded maximum session limit&quot;, 
<span class="fc" id="L261">                userId.toString(), &quot;WARNING&quot;, </span>
<span class="fc" id="L262">                Map.of(&quot;userId&quot;, userId, &quot;sessionCount&quot;, sessionCount.get()));</span>
<span class="fc" id="L263">            return null;</span>
        }
        
        // ØªÙˆÙ„ÛŒØ¯ session ID Ø§Ù…Ù†
<span class="fc" id="L267">        String sessionId = generateSecureSessionId();</span>
        
        // Ø§ÛŒØ¬Ø§Ø¯ session
<span class="fc" id="L270">        SessionInfo sessionInfo = new SessionInfo(sessionId, userId, userAgent, ipAddress);</span>
<span class="fc" id="L271">        activeSessions.put(sessionId, sessionInfo);</span>
<span class="fc" id="L272">        sessionCount.incrementAndGet();</span>
        
<span class="fc" id="L274">        logSecurityEvent(&quot;SESSION_CREATED&quot;, </span>
            &quot;New session created&quot;, 
<span class="fc" id="L276">            userId.toString(), &quot;INFO&quot;, </span>
<span class="fc" id="L277">            Map.of(&quot;userId&quot;, userId, &quot;sessionId&quot;, sessionId, &quot;ipAddress&quot;, ipAddress));</span>
        
<span class="fc" id="L279">        return sessionId;</span>
    }
    
    /**
     * Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ session
     * 
     * @param sessionId Ø´Ù†Ø§Ø³Ù‡ session
     * @return true Ø§Ú¯Ø± session Ù…Ø¹ØªØ¨Ø± Ø¨Ø§Ø´Ø¯
     */
    public static boolean validateSession(String sessionId) {
<span class="pc bpc" id="L289" title="1 of 4 branches missed.">        if (sessionId == null || sessionId.trim().isEmpty()) {</span>
<span class="fc" id="L290">            return false;</span>
        }
        
<span class="fc" id="L293">        SessionInfo sessionInfo = activeSessions.get(sessionId);</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">        if (sessionInfo == null) {</span>
<span class="fc" id="L295">            return false;</span>
        }
        
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">        if (sessionInfo.isExpired()) {</span>
<span class="nc" id="L299">            removeSession(sessionId);</span>
<span class="nc" id="L300">            return false;</span>
        }
        
<span class="fc" id="L303">        sessionInfo.updateLastAccessed();</span>
<span class="fc" id="L304">        return true;</span>
    }
    
    /**
     * Ø­Ø°Ù session
     * 
     * @param sessionId Ø´Ù†Ø§Ø³Ù‡ session
     */
    public static void removeSession(String sessionId) {
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (sessionId == null) return;</span>
        
<span class="fc" id="L315">        SessionInfo sessionInfo = activeSessions.remove(sessionId);</span>
<span class="pc bpc" id="L316" title="1 of 2 branches missed.">        if (sessionInfo != null) {</span>
<span class="fc" id="L317">            String userId = sessionInfo.getUserId().toString();</span>
<span class="fc" id="L318">            AtomicLong sessionCount = userSessionCounts.get(userId);</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">            if (sessionCount != null) {</span>
<span class="fc" id="L320">                sessionCount.decrementAndGet();</span>
            }
            
<span class="fc" id="L323">            logSecurityEvent(&quot;SESSION_REMOVED&quot;, </span>
                &quot;Session removed&quot;, 
                userId, &quot;INFO&quot;, 
<span class="fc" id="L326">                Map.of(&quot;userId&quot;, sessionInfo.getUserId(), &quot;sessionId&quot;, sessionId));</span>
        }
<span class="fc" id="L328">    }</span>
    
    /**
     * Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ session Ù‡Ø§ÛŒ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡
     */
    public static void cleanupExpiredSessions() {
<span class="fc" id="L334">        List&lt;String&gt; expiredSessions = new ArrayList&lt;&gt;();</span>
        
<span class="fc bfc" id="L336" title="All 2 branches covered.">        for (Map.Entry&lt;String, SessionInfo&gt; entry : activeSessions.entrySet()) {</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">            if (entry.getValue().isExpired()) {</span>
<span class="nc" id="L338">                expiredSessions.add(entry.getKey());</span>
            }
<span class="fc" id="L340">        }</span>
        
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">        for (String sessionId : expiredSessions) {</span>
<span class="nc" id="L343">            removeSession(sessionId);</span>
<span class="nc" id="L344">        }</span>
        
<span class="pc bpc" id="L346" title="1 of 2 branches missed.">        if (!expiredSessions.isEmpty()) {</span>
<span class="nc" id="L347">            logSecurityEvent(&quot;SESSIONS_CLEANUP&quot;, </span>
<span class="nc" id="L348">                &quot;Cleaned up &quot; + expiredSessions.size() + &quot; expired sessions&quot;, </span>
                &quot;SYSTEM&quot;, &quot;INFO&quot;, 
<span class="nc" id="L350">                Map.of(&quot;expiredCount&quot;, expiredSessions.size()));</span>
        }
<span class="fc" id="L352">    }</span>
    
    // ===== Threat Detection Methods =====
    
    /**
     * ØªØ´Ø®ÛŒØµ ØªÙ‡Ø¯ÛŒØ¯Ø§Øª Ø¯Ø± ÙˆØ±ÙˆØ¯ÛŒ
     * 
     * @param input ÙˆØ±ÙˆØ¯ÛŒ Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø±Ø³ÛŒ
     * @param identifier Ø´Ù†Ø§Ø³Ù‡ Ù…Ù†Ø¨Ø¹ (IPØŒ userIdØŒ etc.)
     * @return true Ø§Ú¯Ø± ØªÙ‡Ø¯ÛŒØ¯ ØªØ´Ø®ÛŒØµ Ø¯Ø§Ø¯Ù‡ Ø´ÙˆØ¯
     */
    public static boolean detectThreats(String input, String identifier) {
<span class="fc bfc" id="L364" title="All 4 branches covered.">        if (input == null || identifier == null) {</span>
<span class="fc" id="L365">            return false;</span>
        }
        
<span class="fc" id="L368">        boolean threatDetected = false;</span>
<span class="fc" id="L369">        String threatType = null;</span>
        
        // Ø¨Ø±Ø±Ø³ÛŒ SQL Injection
<span class="fc bfc" id="L372" title="All 2 branches covered.">        if (SQL_INJECTION_PATTERN.matcher(input).find()) {</span>
<span class="fc" id="L373">            threatDetected = true;</span>
<span class="fc" id="L374">            threatType = &quot;SQL_INJECTION&quot;;</span>
        }
        
        // Ø¨Ø±Ø±Ø³ÛŒ XSS
<span class="fc bfc" id="L378" title="All 2 branches covered.">        if (XSS_PATTERN.matcher(input).find()) {</span>
<span class="fc" id="L379">            threatDetected = true;</span>
<span class="fc" id="L380">            threatType = &quot;XSS&quot;;</span>
        }
        
        // Ø¨Ø±Ø±Ø³ÛŒ Path Traversal
<span class="fc bfc" id="L384" title="All 2 branches covered.">        if (PATH_TRAVERSAL_PATTERN.matcher(input).find()) {</span>
<span class="fc" id="L385">            threatDetected = true;</span>
<span class="fc" id="L386">            threatType = &quot;PATH_TRAVERSAL&quot;;</span>
        }
        
<span class="fc bfc" id="L389" title="All 2 branches covered.">        if (threatDetected) {</span>
<span class="fc" id="L390">            recordThreat(identifier, threatType, input);</span>
<span class="fc" id="L391">            logSecurityEvent(&quot;THREAT_DETECTED&quot;, </span>
                &quot;Security threat detected: &quot; + threatType, 
                identifier, &quot;HIGH&quot;, 
<span class="fc" id="L394">                Map.of(&quot;threatType&quot;, threatType, &quot;input&quot;, input));</span>
        }
        
<span class="fc" id="L397">        return threatDetected;</span>
    }
    
    /**
     * Ø«Ø¨Øª ØªÙ‡Ø¯ÛŒØ¯
     * 
     * @param identifier Ø´Ù†Ø§Ø³Ù‡ Ù…Ù†Ø¨Ø¹
     * @param threatType Ù†ÙˆØ¹ ØªÙ‡Ø¯ÛŒØ¯
     * @param details Ø¬Ø²Ø¦ÛŒØ§Øª ØªÙ‡Ø¯ÛŒØ¯
     */
    private static void recordThreat(String identifier, String threatType, String details) {
<span class="fc" id="L408">        String key = identifier + &quot;:&quot; + threatType;</span>
<span class="fc" id="L409">        ThreatInfo threatInfo = threatTracker.computeIfAbsent(key, k -&gt; new ThreatInfo(identifier, threatType));</span>
<span class="fc" id="L410">        threatInfo.incrementOccurrence();</span>
<span class="fc" id="L411">    }</span>
    
    // ===== Security Event Logging =====
    
    /**
     * Ø«Ø¨Øª Ø±ÙˆÛŒØ¯Ø§Ø¯ Ø§Ù…Ù†ÛŒØªÛŒ
     * 
     * @param eventType Ù†ÙˆØ¹ Ø±ÙˆÛŒØ¯Ø§Ø¯
     * @param description ØªÙˆØ¶ÛŒØ­Ø§Øª
     * @param identifier Ø´Ù†Ø§Ø³Ù‡
     * @param severity Ø³Ø·Ø­ Ø§Ù‡Ù…ÛŒØª (INFO, WARNING, HIGH, CRITICAL)
     * @param details Ø¬Ø²Ø¦ÛŒØ§Øª Ø§Ø¶Ø§ÙÛŒ
     */
    public static void logSecurityEvent(String eventType, String description, String identifier, 
                                      String severity, Map&lt;String, Object&gt; details) {
<span class="fc" id="L426">        SecurityEvent event = new SecurityEvent(eventType, description, identifier, severity, details);</span>
<span class="fc" id="L427">        securityEvents.add(event);</span>
        
        // Ú†Ø§Ù¾ Ø¯Ø± console Ø¨Ø±Ø§ÛŒ debugging
<span class="fc" id="L430">        System.out.println(&quot;ğŸ”’ Security Event: &quot; + event.toString());</span>
        
        // Ø§Ú¯Ø± Ø±ÙˆÛŒØ¯Ø§Ø¯ Ø¨Ø­Ø±Ø§Ù†ÛŒ Ø§Ø³ØªØŒ Ø§Ù‚Ø¯Ø§Ù…Ø§Øª Ø§Ø¶Ø§ÙÛŒ Ø§Ù†Ø¬Ø§Ù… Ø¯Ù‡ÛŒØ¯
<span class="pc bpc" id="L433" title="1 of 2 branches missed.">        if (&quot;CRITICAL&quot;.equals(severity)) {</span>
<span class="nc" id="L434">            handleCriticalEvent(event);</span>
        }
<span class="fc" id="L436">    }</span>
    
    /**
     * Ù…Ø¯ÛŒØ±ÛŒØª Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ø¨Ø­Ø±Ø§Ù†ÛŒ
     * 
     * @param event Ø±ÙˆÛŒØ¯Ø§Ø¯ Ø¨Ø­Ø±Ø§Ù†ÛŒ
     */
    private static void handleCriticalEvent(SecurityEvent event) {
        // Ø¯Ø± Ø§ÛŒÙ†Ø¬Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ù‚Ø¯Ø§Ù…Ø§Øª Ø§Ø¶Ø§ÙÛŒ Ù…Ø§Ù†Ù†Ø¯:
        // - Ø§Ø±Ø³Ø§Ù„ Ù‡Ø´Ø¯Ø§Ø± Ø¨Ù‡ Ù…Ø¯ÛŒØ± Ø³ÛŒØ³ØªÙ…
        // - Ù…Ø³Ø¯ÙˆØ¯ Ú©Ø±Ø¯Ù† IP
        // - Ø«Ø¨Øª Ø¯Ø± ÙØ§ÛŒÙ„ Ù„Ø§Ú¯ Ø¬Ø¯Ø§Ú¯Ø§Ù†Ù‡
        // - Ø§Ø±Ø³Ø§Ù„ Ø§ÛŒÙ…ÛŒÙ„ Ù‡Ø´Ø¯Ø§Ø±
        
<span class="nc" id="L450">        System.err.println(&quot;ğŸš¨ CRITICAL SECURITY EVENT: &quot; + event.getDescription());</span>
<span class="nc" id="L451">    }</span>
    
    /**
     * Ø¯Ø±ÛŒØ§ÙØª Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ø§Ù…Ù†ÛŒØªÛŒ
     * 
     * @param limit ØªØ¹Ø¯Ø§Ø¯ Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ø¨Ø§Ø²Ú¯Ø´ØªÛŒ
     * @return Ù„ÛŒØ³Øª Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§
     */
    public static List&lt;SecurityEvent&gt; getSecurityEvents(int limit) {
<span class="fc" id="L460">        int size = securityEvents.size();</span>
<span class="fc" id="L461">        int startIndex = Math.max(0, size - limit);</span>
<span class="fc" id="L462">        return new ArrayList&lt;&gt;(securityEvents.subList(startIndex, size));</span>
    }
    
    /**
     * Ø¯Ø±ÛŒØ§ÙØª Ø¢Ù…Ø§Ø± ØªÙ‡Ø¯ÛŒØ¯Ø§Øª
     * 
     * @return Map Ø´Ø§Ù…Ù„ Ø¢Ù…Ø§Ø± ØªÙ‡Ø¯ÛŒØ¯Ø§Øª
     */
    public static Map&lt;String, Object&gt; getThreatStatistics() {
<span class="fc" id="L471">        Map&lt;String, Object&gt; stats = new HashMap&lt;&gt;();</span>
<span class="fc" id="L472">        stats.put(&quot;totalThreats&quot;, threatTracker.size());</span>
<span class="fc" id="L473">        stats.put(&quot;activeSessions&quot;, activeSessions.size());</span>
<span class="fc" id="L474">        stats.put(&quot;securityEvents&quot;, securityEvents.size());</span>
        
        // Ø¢Ù…Ø§Ø± ØªÙ‡Ø¯ÛŒØ¯Ø§Øª Ø¨Ø± Ø§Ø³Ø§Ø³ Ù†ÙˆØ¹
<span class="fc" id="L477">        Map&lt;String, Long&gt; threatTypeCounts = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L478" title="All 2 branches covered.">        for (ThreatInfo threat : threatTracker.values()) {</span>
<span class="fc" id="L479">            threatTypeCounts.merge(threat.getThreatType(), 1L, Long::sum);</span>
<span class="fc" id="L480">        }</span>
<span class="fc" id="L481">        stats.put(&quot;threatTypeCounts&quot;, threatTypeCounts);</span>
        
<span class="fc" id="L483">        return stats;</span>
    }
    
    // ===== Utility Methods =====
    
    /**
     * ØªÙˆÙ„ÛŒØ¯ Ø´Ù†Ø§Ø³Ù‡ session Ø§Ù…Ù†
     * 
     * @return Ø´Ù†Ø§Ø³Ù‡ session
     */
    private static String generateSecureSessionId() {
<span class="fc" id="L494">        byte[] randomBytes = new byte[SESSION_ID_LENGTH];</span>
<span class="fc" id="L495">        secureRandom.nextBytes(randomBytes);</span>
<span class="fc" id="L496">        return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);</span>
    }
    
    /**
     * ØªÙˆÙ„ÛŒØ¯ Ú©Ù„ÛŒØ¯ ØªØµØ§Ø¯ÙÛŒ Ø§Ù…Ù†
     * 
     * @param length Ø·ÙˆÙ„ Ú©Ù„ÛŒØ¯
     * @return Ú©Ù„ÛŒØ¯ ØªØµØ§Ø¯ÙÛŒ
     */
    public static String generateSecureKey(int length) {
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">        if (length &lt;= 0) length = 32;</span>
        
<span class="fc" id="L508">        byte[] keyBytes = new byte[length];</span>
<span class="fc" id="L509">        secureRandom.nextBytes(keyBytes);</span>
<span class="fc" id="L510">        return Base64.getUrlEncoder().withoutPadding().encodeToString(keyBytes);</span>
    }
    
    /**
     * Ø¨Ø±Ø±Ø³ÛŒ Ø§Ù…Ù†ÛŒØª ÙØ§ÛŒÙ„
     * 
     * @param filename Ù†Ø§Ù… ÙØ§ÛŒÙ„
     * @return true Ø§Ú¯Ø± ÙØ§ÛŒÙ„ Ø§Ù…Ù† Ø¨Ø§Ø´Ø¯
     */
    public static boolean isSecureFilename(String filename) {
<span class="fc bfc" id="L520" title="All 4 branches covered.">        if (filename == null || filename.trim().isEmpty()) {</span>
<span class="fc" id="L521">            return false;</span>
        }
        
        // Ø¨Ø±Ø±Ø³ÛŒ Ù¾Ø³ÙˆÙ†Ø¯Ù‡Ø§ÛŒ Ø®Ø·Ø±Ù†Ø§Ú©
<span class="fc" id="L525">        String lowerFilename = filename.toLowerCase();</span>
<span class="fc" id="L526">        String[] dangerousExtensions = {&quot;.exe&quot;, &quot;.bat&quot;, &quot;.cmd&quot;, &quot;.com&quot;, &quot;.pif&quot;, &quot;.scr&quot;, &quot;.vbs&quot;, &quot;.js&quot;};</span>
        
<span class="fc bfc" id="L528" title="All 2 branches covered.">        for (String ext : dangerousExtensions) {</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">            if (lowerFilename.endsWith(ext)) {</span>
<span class="fc" id="L530">                return false;</span>
            }
        }
        
        // Ø¨Ø±Ø±Ø³ÛŒ Ú©Ø§Ø±Ø§Ú©ØªØ±Ù‡Ø§ÛŒ Ø®Ø·Ø±Ù†Ø§Ú©
<span class="fc bfc" id="L535" title="All 2 branches covered.">        return !filename.contains(&quot;..&quot;) &amp;&amp; </span>
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">               !filename.contains(&quot;\\&quot;) &amp;&amp; </span>
<span class="pc bpc" id="L537" title="1 of 2 branches missed.">               !filename.contains(&quot;/&quot;) &amp;&amp;</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">               !filename.contains(&quot;:&quot;) &amp;&amp;</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">               !filename.contains(&quot;*&quot;) &amp;&amp;</span>
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">               !filename.contains(&quot;?&quot;) &amp;&amp;</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">               !filename.contains(&quot;\&quot;&quot;) &amp;&amp;</span>
<span class="pc bpc" id="L542" title="1 of 2 branches missed.">               !filename.contains(&quot;&lt;&quot;) &amp;&amp;</span>
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">               !filename.contains(&quot;&gt;&quot;) &amp;&amp;</span>
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">               !filename.contains(&quot;|&quot;);</span>
    }
    
    /**
     * Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù‚Ø¯ÛŒÙ…ÛŒ
     */
    public static void cleanupOldData() {
        // Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ session Ù‡Ø§ÛŒ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡
<span class="fc" id="L552">        cleanupExpiredSessions();</span>
        
        // Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ù‚Ø¯ÛŒÙ…ÛŒ (Ø¨ÛŒØ´ Ø§Ø² 30 Ø±ÙˆØ²)
<span class="fc" id="L555">        LocalDateTime cutoffEvents = LocalDateTime.now().minusDays(30);</span>
<span class="fc" id="L556">        securityEvents.removeIf(event -&gt; event.getTimestamp().isBefore(cutoffEvents));</span>
        
        // Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ ØªÙ‡Ø¯ÛŒØ¯Ø§Øª Ù‚Ø¯ÛŒÙ…ÛŒ (Ø¨ÛŒØ´ Ø§Ø² 7 Ø±ÙˆØ²)
<span class="fc" id="L559">        LocalDateTime cutoffThreats = LocalDateTime.now().minusDays(7);</span>
<span class="fc" id="L560">        threatTracker.entrySet().removeIf(entry -&gt; </span>
<span class="fc" id="L561">            entry.getValue().getLastDetected().isBefore(cutoffThreats));</span>
<span class="fc" id="L562">    }</span>
} 
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>