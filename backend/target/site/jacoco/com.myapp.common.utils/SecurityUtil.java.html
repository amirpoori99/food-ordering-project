<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SecurityUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Food Ordering Backend</a> &gt; <a href="index.source.html" class="el_package">com.myapp.common.utils</a> &gt; <span class="el_source">SecurityUtil.java</span></div><h1>SecurityUtil.java</h1><pre class="source lang-java linenums">package com.myapp.common.utils;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.Map;
import java.util.Set;
import java.util.HashSet;
import java.util.concurrent.TimeUnit;
import java.util.HashMap;

/**
 * کلاس ابزاری امنیت پیشرفته
 * این کلاس قابلیت‌های امنیتی پیشرفته را فراهم می‌کند:
 * - Rate Limiting برای جلوگیری از حملات
 * - اعتبارسنجی ورودی و پاک‌سازی
 * - اعتبارسنجی رمز عبور
 * - مدیریت IP های مشکوک
 * - تولید header های امنیتی
 * 
 * @author Food Ordering System Team
 * @version 1.0
 * @since 2024
 */
<span class="nc" id="L28">public class SecurityUtil {</span>
    
    // ===== Rate Limiting Configuration =====
    private static final int MAX_REQUESTS_PER_MINUTE = 60;
    private static final int MAX_REQUESTS_PER_HOUR = 1000;
    private static final int MAX_LOGIN_ATTEMPTS = 5;
    private static final int LOGIN_BLOCK_DURATION_MINUTES = 15;
    
    // ===== Password Validation =====
    private static final int MIN_PASSWORD_LENGTH = 8;
    private static final int MAX_PASSWORD_LENGTH = 128;
<span class="fc" id="L39">    private static final Pattern PASSWORD_PATTERN = Pattern.compile(</span>
        &quot;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&amp;#])[A-Za-z\\d@$!%*?&amp;#]{&quot; + MIN_PASSWORD_LENGTH + &quot;,&quot; + MAX_PASSWORD_LENGTH + &quot;}$&quot;
    );
    
    // ===== Input Validation Patterns =====
<span class="fc" id="L44">    private static final Pattern PHONE_PATTERN = Pattern.compile(&quot;^09\\d{9}$&quot;);</span>
<span class="fc" id="L45">    private static final Pattern EMAIL_PATTERN = Pattern.compile(</span>
        &quot;^(?!.*\\.\\.)[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$&quot;
    );
<span class="fc" id="L48">    private static final Pattern NAME_PATTERN = Pattern.compile(&quot;^[\\u0600-\\u06FF\\sA-Za-z]{2,50}$&quot;);</span>
    
    // ===== Rate Limiting Storage =====
<span class="fc" id="L51">    private static final Map&lt;String, RequestCounter&gt; rateLimitMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L52">    private static final Map&lt;String, LoginAttempt&gt; loginAttemptsMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L53">    private static final Set&lt;String&gt; blockedIPs = ConcurrentHashMap.newKeySet();</span>
    
    // ===== Security Headers =====
<span class="fc" id="L56">    private static final Map&lt;String, String&gt; SECURITY_HEADERS = Map.of(</span>
        &quot;X-Content-Type-Options&quot;, &quot;nosniff&quot;,
        &quot;X-Frame-Options&quot;, &quot;DENY&quot;,
        &quot;X-XSS-Protection&quot;, &quot;1; mode=block&quot;,
        &quot;Strict-Transport-Security&quot;, &quot;max-age=31536000; includeSubDomains&quot;,
        &quot;Content-Security-Policy&quot;, &quot;default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'&quot;,
        &quot;Referrer-Policy&quot;, &quot;strict-origin-when-cross-origin&quot;
    );
    
    /**
     * کلاس شمارنده درخواست‌ها برای Rate Limiting
     */
<span class="fc" id="L68">    private static class RequestCounter {</span>
<span class="fc" id="L69">        private final AtomicInteger minuteCount = new AtomicInteger(0);</span>
<span class="fc" id="L70">        private final AtomicInteger hourCount = new AtomicInteger(0);</span>
<span class="fc" id="L71">        private volatile long lastMinuteReset = System.currentTimeMillis();</span>
<span class="fc" id="L72">        private volatile long lastHourReset = System.currentTimeMillis();</span>
        
        public boolean canMakeRequest() {
<span class="fc" id="L75">            long now = System.currentTimeMillis();</span>
            
            // Reset minute counter if needed
<span class="pc bpc" id="L78" title="1 of 2 branches missed.">            if (now - lastMinuteReset &gt; TimeUnit.MINUTES.toMillis(1)) {</span>
<span class="nc" id="L79">                minuteCount.set(0);</span>
<span class="nc" id="L80">                lastMinuteReset = now;</span>
            }
            
            // Reset hour counter if needed
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">            if (now - lastHourReset &gt; TimeUnit.HOURS.toMillis(1)) {</span>
<span class="nc" id="L85">                hourCount.set(0);</span>
<span class="nc" id="L86">                lastHourReset = now;</span>
            }
            
            // Check limits
<span class="fc bfc" id="L90" title="All 2 branches covered.">            return minuteCount.get() &lt; MAX_REQUESTS_PER_MINUTE &amp;&amp; </span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">                   hourCount.get() &lt; MAX_REQUESTS_PER_HOUR;</span>
        }
        
        public void increment() {
<span class="fc" id="L95">            minuteCount.incrementAndGet();</span>
<span class="fc" id="L96">            hourCount.incrementAndGet();</span>
<span class="fc" id="L97">        }</span>
        
        public int getMinuteCount() {
<span class="nc" id="L100">            return minuteCount.get();</span>
        }
        
        public int getHourCount() {
<span class="nc" id="L104">            return hourCount.get();</span>
        }
    }
    
    /**
     * کلاس مدیریت تلاش‌های ورود
     */
<span class="fc" id="L111">    private static class LoginAttempt {</span>
<span class="fc" id="L112">        private final AtomicInteger attemptCount = new AtomicInteger(0);</span>
<span class="fc" id="L113">        private volatile long firstAttemptTime = System.currentTimeMillis();</span>
<span class="fc" id="L114">        private volatile long lastAttemptTime = System.currentTimeMillis();</span>
        
        public boolean isBlocked() {
<span class="fc" id="L117">            long now = System.currentTimeMillis();</span>
<span class="fc" id="L118">            long timeSinceFirstAttempt = now - firstAttemptTime;</span>
            
            // Reset if block duration has passed
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">            if (timeSinceFirstAttempt &gt; TimeUnit.MINUTES.toMillis(LOGIN_BLOCK_DURATION_MINUTES)) {</span>
<span class="nc" id="L122">                attemptCount.set(0);</span>
<span class="nc" id="L123">                firstAttemptTime = now;</span>
<span class="nc" id="L124">                return false;</span>
            }
            
<span class="fc bfc" id="L127" title="All 2 branches covered.">            return attemptCount.get() &gt;= MAX_LOGIN_ATTEMPTS;</span>
        }
        
        public void recordAttempt() {
<span class="fc" id="L131">            attemptCount.incrementAndGet();</span>
<span class="fc" id="L132">            lastAttemptTime = System.currentTimeMillis();</span>
<span class="fc" id="L133">        }</span>
        
        public int getAttemptCount() {
<span class="fc" id="L136">            return attemptCount.get();</span>
        }
        
        public long getRemainingBlockTime() {
<span class="nc bnc" id="L140" title="All 2 branches missed.">            if (!isBlocked()) return 0;</span>
<span class="nc" id="L141">            long now = System.currentTimeMillis();</span>
<span class="nc" id="L142">            long timeSinceFirstAttempt = now - firstAttemptTime;</span>
<span class="nc" id="L143">            return Math.max(0, TimeUnit.MINUTES.toMillis(LOGIN_BLOCK_DURATION_MINUTES) - timeSinceFirstAttempt);</span>
        }
    }
    
    // ===== Rate Limiting Methods =====
    
    /**
     * بررسی Rate Limiting برای IP یا شناسه کاربر
     * 
     * @param identifier شناسه (IP یا userId)
     * @return true اگر درخواست مجاز باشد، در غیر اینصورت false
     */
    public static boolean checkRateLimit(String identifier) {
<span class="fc bfc" id="L156" title="All 4 branches covered.">        if (identifier == null || identifier.trim().isEmpty()) {</span>
<span class="fc" id="L157">            return false;</span>
        }
        
        // Check if IP is blocked
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">        if (blockedIPs.contains(identifier)) {</span>
<span class="nc" id="L162">            return false;</span>
        }
        
<span class="fc" id="L165">        RequestCounter counter = rateLimitMap.computeIfAbsent(identifier, k -&gt; new RequestCounter());</span>
        
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (counter.canMakeRequest()) {</span>
<span class="fc" id="L168">            counter.increment();</span>
<span class="fc" id="L169">            return true;</span>
        }
        
<span class="fc" id="L172">        return false;</span>
    }
    
    /**
     * ثبت تلاش ورود ناموفق
     * 
     * @param identifier شناسه (IP یا phone)
     * @return true اگر IP مسدود شده باشد، در غیر اینصورت false
     */
    public static boolean recordFailedLogin(String identifier) {
<span class="pc bpc" id="L182" title="2 of 4 branches missed.">        if (identifier == null || identifier.trim().isEmpty()) {</span>
<span class="nc" id="L183">            return false;</span>
        }
        
<span class="fc" id="L186">        LoginAttempt attempt = loginAttemptsMap.computeIfAbsent(identifier, k -&gt; new LoginAttempt());</span>
<span class="fc" id="L187">        attempt.recordAttempt();</span>
        
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (attempt.isBlocked()) {</span>
<span class="fc" id="L190">            blockedIPs.add(identifier);</span>
<span class="fc" id="L191">            return true;</span>
        }
        
<span class="fc" id="L194">        return false;</span>
    }
    
    /**
     * پاک‌سازی تلاش‌های ورود موفق
     * 
     * @param identifier شناسه (IP یا phone)
     */
    public static void clearLoginAttempts(String identifier) {
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        if (identifier != null) {</span>
<span class="fc" id="L204">            loginAttemptsMap.remove(identifier);</span>
<span class="fc" id="L205">            blockedIPs.remove(identifier);</span>
        }
<span class="fc" id="L207">    }</span>
    
    /**
     * دریافت تعداد تلاش‌های ورود باقیمانده
     * 
     * @param identifier شناسه (IP یا phone)
     * @return تعداد تلاش‌های باقیمانده
     */
    public static int getRemainingLoginAttempts(String identifier) {
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        if (identifier == null) return 0;</span>
        
<span class="fc" id="L218">        LoginAttempt attempt = loginAttemptsMap.get(identifier);</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">        if (attempt == null) return MAX_LOGIN_ATTEMPTS;</span>
        
<span class="fc bfc" id="L221" title="All 2 branches covered.">        if (attempt.isBlocked()) return 0;</span>
<span class="fc" id="L222">        return Math.max(0, MAX_LOGIN_ATTEMPTS - attempt.getAttemptCount());</span>
    }
    
    // ===== Input Validation Methods =====
    
    /**
     * اعتبارسنجی شماره تلفن
     * 
     * @param phone شماره تلفن
     * @return true اگر شماره معتبر باشد، در غیر اینصورت false
     */
    public static boolean isValidPhone(String phone) {
<span class="pc bpc" id="L234" title="1 of 4 branches missed.">        if (phone == null || phone.trim().isEmpty()) {</span>
<span class="fc" id="L235">            return false;</span>
        }
<span class="fc" id="L237">        return PHONE_PATTERN.matcher(phone.trim()).matches();</span>
    }
    
    /**
     * اعتبارسنجی ایمیل
     * 
     * @param email آدرس ایمیل
     * @return true اگر ایمیل معتبر باشد، در غیر اینصورت false
     */
    public static boolean isValidEmail(String email) {
<span class="pc bpc" id="L247" title="2 of 4 branches missed.">        if (email == null || email.trim().isEmpty()) {</span>
<span class="nc" id="L248">            return false;</span>
        }
<span class="fc" id="L250">        return EMAIL_PATTERN.matcher(email.trim().toLowerCase()).matches();</span>
    }
    
    /**
     * اعتبارسنجی نام
     * 
     * @param name نام
     * @return true اگر نام معتبر باشد، در غیر اینصورت false
     */
    public static boolean isValidName(String name) {
<span class="pc bpc" id="L260" title="1 of 4 branches missed.">        if (name == null || name.trim().isEmpty()) {</span>
<span class="fc" id="L261">            return false;</span>
        }
<span class="fc" id="L263">        return NAME_PATTERN.matcher(name.trim()).matches();</span>
    }
    
    /**
     * اعتبارسنجی رمز عبور
     * 
     * @param password رمز عبور
     * @return true اگر رمز عبور معتبر باشد، در غیر اینصورت false
     */
    public static boolean isValidPassword(String password) {
<span class="pc bpc" id="L273" title="1 of 4 branches missed.">        if (password == null || password.length() &lt; MIN_PASSWORD_LENGTH || </span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">            password.length() &gt; MAX_PASSWORD_LENGTH) {</span>
<span class="fc" id="L275">            return false;</span>
        }
<span class="fc" id="L277">        return PASSWORD_PATTERN.matcher(password).matches();</span>
    }
    
    /**
     * دریافت پیام خطای اعتبارسنجی رمز عبور
     * 
     * @param password رمز عبور
     * @return پیام خطا یا null اگر رمز عبور معتبر باشد
     */
    public static String getPasswordValidationError(String password) {
<span class="fc bfc" id="L287" title="All 2 branches covered.">        if (password == null) {</span>
<span class="fc" id="L288">            return &quot;رمز عبور نمی‌تواند خالی باشد&quot;;</span>
        }
        
<span class="fc bfc" id="L291" title="All 2 branches covered.">        if (password.length() &lt; MIN_PASSWORD_LENGTH) {</span>
<span class="fc" id="L292">            return &quot;رمز عبور باید حداقل &quot; + MIN_PASSWORD_LENGTH + &quot; کاراکتر باشد&quot;;</span>
        }
        
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">        if (password.length() &gt; MAX_PASSWORD_LENGTH) {</span>
<span class="nc" id="L296">            return &quot;رمز عبور نمی‌تواند بیشتر از &quot; + MAX_PASSWORD_LENGTH + &quot; کاراکتر باشد&quot;;</span>
        }
        
<span class="fc bfc" id="L299" title="All 2 branches covered.">        if (!password.matches(&quot;.*[a-z].*&quot;)) {</span>
<span class="fc" id="L300">            return &quot;رمز عبور باید شامل حداقل یک حرف کوچک باشد&quot;;</span>
        }
        
<span class="fc bfc" id="L303" title="All 2 branches covered.">        if (!password.matches(&quot;.*[A-Z].*&quot;)) {</span>
<span class="fc" id="L304">            return &quot;رمز عبور باید شامل حداقل یک حرف بزرگ باشد&quot;;</span>
        }
        
<span class="fc bfc" id="L307" title="All 2 branches covered.">        if (!password.matches(&quot;.*\\d.*&quot;)) {</span>
<span class="fc" id="L308">            return &quot;رمز عبور باید شامل حداقل یک عدد باشد&quot;;</span>
        }
        
<span class="fc bfc" id="L311" title="All 2 branches covered.">        if (!password.matches(&quot;.*[@$!%*?&amp;].*&quot;)) {</span>
<span class="fc" id="L312">            return &quot;رمز عبور باید شامل حداقل یک کاراکتر خاص (@$!%*?&amp;) باشد&quot;;</span>
        }
        
<span class="fc" id="L315">        return null; // رمز عبور معتبر است</span>
    }
    
    // ===== Input Sanitization Methods =====
    
    /**
     * پاک‌سازی ورودی از کاراکترهای خطرناک
     * 
     * @param input ورودی
     * @return ورودی پاک‌سازی شده
     */
    public static String sanitizeInput(String input) {
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">        if (input == null) return null;</span>
        
<span class="fc" id="L329">        return input.trim()</span>
<span class="fc" id="L330">                   .replaceAll(&quot;&lt;script[^&gt;]*&gt;.*?&lt;/script&gt;&quot;, &quot;&quot;) // Remove script tags</span>
<span class="fc" id="L331">                   .replaceAll(&quot;&lt;[^&gt;]*&gt;&quot;, &quot;&quot;) // Remove HTML tags</span>
<span class="fc" id="L332">                   .replaceAll(&quot;javascript:&quot;, &quot;&quot;) // Remove javascript: protocol</span>
<span class="fc" id="L333">                   .replaceAll(&quot;on\\w+\\s*=&quot;, &quot;&quot;) // Remove event handlers</span>
<span class="fc" id="L334">                   .replaceAll(&quot;(?i)\\b(union|select|insert|update|delete|drop|create|alter)\\b&quot;, &quot;&quot;); // Remove SQL keywords</span>
    }
    
    /**
     * پاک‌سازی نام فایل
     * 
     * @param filename نام فایل
     * @return نام فایل پاک‌سازی شده
     */
    public static String sanitizeFilename(String filename) {
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">        if (filename == null) return null;</span>
        
<span class="fc" id="L346">        return filename.replaceAll(&quot;[^a-zA-Z0-9._-]&quot;, &quot;_&quot;)</span>
<span class="fc" id="L347">                      .replaceAll(&quot;_{2,}&quot;, &quot;_&quot;)</span>
<span class="fc" id="L348">                      .replaceAll(&quot;^_|_$&quot;, &quot;&quot;);</span>
    }
    
    // ===== Security Headers Methods =====
    
    /**
     * دریافت header های امنیتی
     * 
     * @return Map شامل header های امنیتی
     */
    public static Map&lt;String, String&gt; getSecurityHeaders() {
<span class="fc" id="L359">        return new HashMap&lt;&gt;(SECURITY_HEADERS);</span>
    }
    
    /**
     * دریافت header امنیتی خاص
     * 
     * @param headerName نام header
     * @return مقدار header یا null اگر وجود نداشته باشد
     */
    public static String getSecurityHeader(String headerName) {
<span class="fc" id="L369">        return SECURITY_HEADERS.get(headerName);</span>
    }
    
    // ===== Utility Methods =====
    
    /**
     * تولید شناسه تصادفی امن
     * 
     * @param length طول شناسه
     * @return شناسه تصادفی
     */
    public static String generateSecureRandomId(int length) {
<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (length &lt;= 0) length = 32;</span>
        
<span class="fc" id="L383">        String chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;;</span>
<span class="fc" id="L384">        StringBuilder sb = new StringBuilder(length);</span>
        
<span class="fc bfc" id="L386" title="All 2 branches covered.">        for (int i = 0; i &lt; length; i++) {</span>
<span class="fc" id="L387">            int index = (int) (Math.random() * chars.length());</span>
<span class="fc" id="L388">            sb.append(chars.charAt(index));</span>
        }
        
<span class="fc" id="L391">        return sb.toString();</span>
    }
    
    /**
     * بررسی امنیت URL
     * 
     * @param url URL برای بررسی
     * @return true اگر URL امن باشد، در غیر اینصورت false
     */
    public static boolean isSecureUrl(String url) {
<span class="fc bfc" id="L401" title="All 4 branches covered.">        if (url == null || url.trim().isEmpty()) {</span>
<span class="fc" id="L402">            return false;</span>
        }
        
<span class="fc" id="L405">        String lowerUrl = url.toLowerCase();</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">        return lowerUrl.startsWith(&quot;https://&quot;) || </span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">               lowerUrl.startsWith(&quot;http://localhost&quot;) ||</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">               lowerUrl.startsWith(&quot;http://127.0.0.1&quot;);</span>
    }
    
    /**
     * پاک‌سازی داده‌های Rate Limiting قدیمی
     * این متد باید به صورت دوره‌ای فراخوانی شود
     */
    public static void cleanupOldData() {
<span class="fc" id="L416">        long now = System.currentTimeMillis();</span>
        
        // Cleanup rate limit data older than 1 hour
<span class="fc" id="L419">        rateLimitMap.entrySet().removeIf(entry -&gt; {</span>
<span class="fc" id="L420">            RequestCounter counter = entry.getValue();</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">            return now - counter.lastMinuteReset &gt; TimeUnit.HOURS.toMillis(1);</span>
        });
        
        // Cleanup login attempts older than 1 hour
<span class="fc" id="L425">        loginAttemptsMap.entrySet().removeIf(entry -&gt; {</span>
<span class="fc" id="L426">            LoginAttempt attempt = entry.getValue();</span>
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">            return now - attempt.lastAttemptTime &gt; TimeUnit.HOURS.toMillis(1);</span>
        });
        
        // Cleanup blocked IPs older than 1 hour
<span class="fc" id="L431">        blockedIPs.removeIf(ip -&gt; {</span>
<span class="fc" id="L432">            LoginAttempt attempt = loginAttemptsMap.get(ip);</span>
<span class="pc bpc" id="L433" title="2 of 4 branches missed.">            return attempt == null || now - attempt.lastAttemptTime &gt; TimeUnit.HOURS.toMillis(1);</span>
        });
<span class="fc" id="L435">    }</span>
    
    /**
     * دریافت آمار Rate Limiting
     * 
     * @return Map شامل آمار
     */
    public static Map&lt;String, Object&gt; getRateLimitStats() {
<span class="fc" id="L443">        Map&lt;String, Object&gt; stats = new HashMap&lt;&gt;();</span>
<span class="fc" id="L444">        stats.put(&quot;activeRateLimits&quot;, rateLimitMap.size());</span>
<span class="fc" id="L445">        stats.put(&quot;activeLoginAttempts&quot;, loginAttemptsMap.size());</span>
<span class="fc" id="L446">        stats.put(&quot;blockedIPs&quot;, blockedIPs.size());</span>
<span class="fc" id="L447">        stats.put(&quot;maxRequestsPerMinute&quot;, MAX_REQUESTS_PER_MINUTE);</span>
<span class="fc" id="L448">        stats.put(&quot;maxRequestsPerHour&quot;, MAX_REQUESTS_PER_HOUR);</span>
<span class="fc" id="L449">        stats.put(&quot;maxLoginAttempts&quot;, MAX_LOGIN_ATTEMPTS);</span>
<span class="fc" id="L450">        return stats;</span>
    }
} 
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>